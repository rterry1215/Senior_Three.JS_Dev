var Text = function(){

  this.PARAM1 = "@@1";
  this.PARAM2 = "@@2";
  this.PARAM3 = "@@3";
  this.PARAM4 = "@@4";
  this.PARAM5 = "@@5";

  this.VERSION = "VERSION";
  this.CODER = "CODER";

  this.ONLY_PARAM = "@@1";
  this.TABULATED_1 = "  @@1";
  this.TABULATED_2 = "    @@1";
  this.TABULATED_3 = "      @@1";
  this.TREE = "|____@@1";
  this.TREE2 = "|___@@1: @@2";
  this.SUBTREE = "   |___@@1";
  this.SUBTREE2 = "   |___@@1: @@2";
  this.COORD_TREE = "|___@@1: (x:@@2, y:@@3, z:@@4)";
  this.COORD_TREE_SIZE = "|___@@1: (width:@@2, height:@@3, depth:@@4)";
  this.COORD_TREE_TAB = "   |___@@1: (x:@@2, y:@@3, z:@@4)";
  this.COORD_TREE_SIZE_TAB = "   |___@@1: (width:@@2, height:@@3, depth:@@4)";
  this.SUBTREE3 = "        |___@@1";
  this.COMMA = ",";
  this.PARAM_WITH_DOTS = "@@1: ";
  this.COMMAND_NOT_FOUND = "Command not found. Type help for list of commands.";
  this.COMMAND_DEPRECATED = "Command deprecated.";
  this.ARGUMENTS_EXPECTED = "@@1 argument(s) expected:";
  this.NO_ARGUMENTS_EXPECTED = "No arguments expected for @@1";
  this.CAMERA_POSITION = "Camera position: (@@1, @@2, @@3)";
  this.CAMERA_DIRECTION = "Camera direction: (@@1, @@2, @@3)";
  this.NO_GRIDSYSTEMS = "There are no GridSystems.";
  this.NO_FONTS = "There are no created fonts.";
  this.FONT_USED_IN = "Font used in text: @@1. Delete the text first.";
  this.NO_OBSTACLES_FOUND = "No obstacles found.";
  this.COMMAND_EXECUTED_FOR_X_OBSTACLES = "Command executed for @@1 obstacles.";
  this.COMMAND_EXECUTED_FOR_X_PARTICLE_SYSTEMS = "Command executed for @@1 particle systems.";
  this.COMMAND_EXECUTED_FOR_X_PARTICLE_SYSTEM_POOLS = "Command executed for @@1 particle system pools.";
  this.NO_PARTICLE_SYSTEMS_FOUND = "No particle systems found.";
  this.NO_PARTICLE_SYSTEM_POOLS_FOUND = "No particle system pools found.";
  this.NO_MUZZLE_FLASHES_FOUND = "No muzzleflashes found.";
  this.COMMAND_EXECUTED_FOR_X_TEXTS = "Command executed for @@1 texts.";
  this.COMMAND_EXECUTED_FOR_X_FONTS = "Command executed for @@1 fonts.";
  this.COMMAND_EXECUTED_FOR_X_MUZZLE_FLASHES = "Command executed for @@1 muzzleflashes.";
  this.COMMAND_EXECUTED_FOR_X_MASSES = "Command executed for @@1 masses.";
  this.NO_TEXT_FOUND = "No text found.";
  this.NO_TEXTS_CREATED = "No texts created.";
  this.NO_FONTS_FOUND = "No fonts found.";
  this.GRIDSYSTEMS = "Grid systems";
  this.NO_MASSES_FOUND = "No masses found.";
  this.NO_SUCH_GRID_SYSTEM = "No such grid system.";
  this.NO_SUCH_CROSSHAIR = "No such crosshair.";
  this.GRID_SYSTEM_IS_OUT_OF = "Grid system is out of world limits. Use setWorldLimits command to increase the limit.";
  this.NO_SUCH_FONT = "No such font.";
  this.NO_SUCH_PARTICLE_SYSTEM = "No such particle system.";
  this.NO_SUCH_PARTICLE_SYSTEM_POOL = "No such particle system pool.";
  this.NO_SUCH_MUZZLE_FLASH = "No such muzzle flash.";
  this.PARTICLE_SYSTEM_BELONGS_TO_ANOTHER_POOL = "Particle system belongs to another pool.";
  this.PARTICLE_SYSTEM_POOL_CREATED = "Particle system pool created.";
  this.TREE_NAME = "|____Name: @@1";
  this.TREE_SIZEX = "|____SizeX: @@1";
  this.TREE_SIZEZ = "|____SizeZ: @@1";
  this.TREE_CENTERX = "|____CenterX: @@1";
  this.TREE_CENTERY = "|____CenterY: @@1";
  this.TREE_CENTERZ = "|____CenterZ: @@1";
  this.TREE_COLOR = "|____Color: @@1";
  this.TREE_OUTLINE_COLOR = "|____Outline Color: @@1";
  this.TREE_CELL_SIZE = "|____Cell Size: @@1";
  this.TREE_CELL_COUNT = "|____Cell Count: @@1";
  this.TREE_AXIS = "|____Axis: @@1";
  this.GRID_SYSTEM_DESTROYED = "Grid system destroyed.";
  this.FONT_DESTROYED = "Font destroyed.";
  this.CONTROLS = "Control Info";
  this.SELECTED_GRIDS = "Selected grids";
  this.FILE_NOT_VALID = "File not valid.";
  this.OBJECT_IMPORTED = "Object imported.";
  this.PS_IMPORTED = "ParticleSystem imported.";
  this.NONE_OF_THE_GRIDS_ARE_SELECTED = "None of the grids are selected.";
  this.GRIDS_RESET = "@@1 grids reset.";
  this.OBJECT_HAS_PIVOT = "Object has pivot. Cannot export.";
  this.CHILD_OBJECT_POSITION = "World position of @@1:";
  this.MUST_HAVE_TWO_GRIDS_SELECTED = "Must have two grids selected.";
  this.SELECTED_GRIDS_SAME_GRIDSYSTEM = "Selected grids must be in the same grid system.";
  this.CROPPED_GS_BUFFER_IS_EMPTY = "Cropped grid system buffer is empty.";
  this.XTRANSLATION_MUST_BE_A_NUMBER = "xTranslation must be a number.";
  this.YTRANSLATION_MUST_BE_A_NUMBER = "yTranslation must be a number.";
  this.ZTRANSLATION_MUST_BE_A_NUMBER = "zTranslation must be a number.";
  this.RADUIS_MUST_BE_A_NUMBER = "Radius must be a number.";
  this.RADIUS_MUST_BE_DIFFERENT_THAN_ZERO = "Radius must be different than zero.";
  this.BOTH_BOTTOM_RADIUS_AND_TOP_RADIUS = "Both bottom radius and top radius cannot be zero.";
  this.SPHERE_CREATED = "Sphere created.";
  this.CYLINDER_CREATED = "Cylinder created.";
  this.JOB_COMPLETED = "Job completed.";
  this.SWITCHED_TO_PREVIEW_MODE = "Switched to preview mode.";
  this.SWITCHED_TO_DESIGN_MODE = "Switched to design mode.";
  this.NAME_RESERVED = "Name reserved.";
  this.BACKGROUND_COLOR_SET = "Background color set.";
  this.MATERIAL_NAME_MUST_BE_UNIQUE = "Material name must be unique.";
  this.PATH_CREATED = "Path created.";
  this.NO_SUCH_PATH = "No such path.";
  this.PATH_NOT_INSIDE_ACTIVE_SCENE = "Path is not inside the active scene.";
  this.PATH_DESTROYED = "Path destroyed.";
  this.NO_PATHS_FOUND = "No paths found.";
  this.COMMAND_EXECUTED_FOR_X_PATHS = "Command executed for @@1 paths.";
  this.LOOP_MUST_BE_TRUE_OR_FALSE = "loop must be true or false.";
  this.REWIND_MUST_BE_TRUE_OR_FALSE = "rewind must be true or false.";
  this.ISWIREFRAMED_MUST_BE_TRUE_OR_FALSE = "isWireFramed must be true or false.";
  this.ISVISIBLE_MUST_BE_TRUE_OR_FALSE = "isVisible must be true or false.";
  this.ISOPENENDED_MUST_BE_TRUE_OR_FALSE = "isOpenEnded must be true or false";
  this.ISHARDCOPY_MUST_BE_TRUE_OR_FALSE = "isHardCopy must be true or false.";
  this.PROPERTY_MUST_BE_TRUE_OR_FALSE = "Property must be true or false.";
  this.SIDES_MUST_BE_BOTH_FRONT_OR_BACK = "sides must be front, back or both.";
  this.ENTITY_IS_EXCLUDED_FROM_HIDE_BEHAVIOR = "Entity is excluded from hide behavior.";
  this.ENTITY_IS_INCLUDED_IN_HIDE_BEHAVIOR = "Entity is included in hide behavior.";
  this.DIFFERENT_GRID_SYSTEM_AXIS = "Source object and target object have different grid system axis.";
  this.SHAPES = "Shapes";
  this.CONFIGURATION_CREATED = "Configuration created.";
  this.MATERIAL_CREATED = "Material created.";
  this.BASIC_MATERIAL_INFO_TREE = "|____BASIC MATERIAL: @@1 -> color: @@2";
  this.MATERIALS = "Materials";
  this.NO_CREATED_MATERIALS = "There are no created materials.";
  this.NO_SUCH_MATERIAL = "No such material.";
  this.MATERIAL_DESTROYED = "Material destroyed.";
  this.MUST_HAVE_1_OR_2_GRIDS_SELECTED = "Must have 1 or 2 grids selected.";
  this.NAME_MUST_BE_UNIQUE = "Name must be unique.";
  this.ID_MUST_BE_UNIQUE = "ID must be unique.";
  this.AI_OBSTACLE_CREATED = "AI obstacle created.";
  this.FONT_NAME_MUST_BE_UNIQUE = "Font name must be unique.";
  this.NAME_USED_AS_A_REFERENCE = "Name used as a copy reference name in an object. Cannot use this name.";
  this.NAME_USED_IN_AN_OBJECT_GROUP = "Name used in an object group.";
  this.NO_SUCH_SPRITE = "No such sprite.";
  this.NO_SPRITES_CREATED = "No sprites created.";
  this.OBJECT_ADDED = "Object added.";
  this.X_GRIDS_SELECTED = "@@1 grids selected.";
  this.OBJECT_INFO_TREE = "|____[@@1]: @@2 (@@3, @@4, @@5)";
  this.OBJECT_GROUP_INFO_TREE = "|____[glued]: @@1 (@@2) (@@3, @@4, @@5)";
  this.NO_OBJECT_ADDED_TO_THE_SCENE = "No objects added to scene.";
  this.OBJECTS = "Objects";
  this.FONTS = "Fonts";
  this.GS_ATTACHED_TO_A_WC = "Gridsystem attached to a wall collection. Use destroyWallCollection command instead.";
  this.NO_SUCH_OBJECT = "No such object.";
  this.NO_SUCH_OBJECT_GROUP = "No such object group.";
  this.OBJECT_ADDED_TO_CONTAINER = "Object added to container.";
  this.CONTAINER_ALREADY_FULL = "Container is already full. Use emptyContainer command first.";
  this.NO_SUCH_CHILD_OBJECT_IN_THE_GROUP = "No such child object in the group.";
  this.NO_META_DATA_TO_SHOW = "No metadata to show.";
  this.METADATA_OF = "Metadata of @@1";
  this.TEXTURE_PACK = "Texture Pack";
  this.MATERIAL_TYPE = "Material Type";
  this.OBJECT_DESTROYED = "Object destroyed.";
  this.MASSES_IN_THIS_SCENE = "Masses in this scene";
  this.DYNAMIC_TEXTURE_FOLDER_WITH_SAME_NAME = "Dynamic texture folder with the same name exists.";
  this.TEXTURE_NAME_NOT_VALID = "Texture name not valid.";
  this.TEXTURE_NAME_MUST_BE_UNIQUE = "Texture name must be unique.";
  this.REPEATU_MUST_BE_A_NUMBER = "repeatU must be a number.";
  this.REPEATV_MUST_BE_A_NUMBER = "repeatV must be a number.";
  this.TEXTURE_CREATED = "Texture created.";
  this.SPRITE_NOT_IN_ACTIVE_SCENE = "Sprite not in active scene.";
  this.SPRITE_SELECTED = "Sprite selected.";
  this.SOURCE_TEXT_IS_NOT_DEFINED = "Source text is not defined.";
  this.TARGET_TEXT_IS_NOT_DEFINED = "Target text is not defined.";
  this.CONTAINER_CREATED = "Container created.";
  this.NO_SUCH_CONTAINER = "No such container.";
  this.CONTAINER_NOT_IN_ACTIVE_SCENE = "Container not inside the active scene.";
  this.PARENT_CONTAINER_NOT_IN_ACTIVE_SCENE = "Parent container not inside active scene.";
  this.CHILD_CONTAINER_NOT_IN_ACTIVE_SCENE = "Child container not inside active scene.";
  this.INVALID_ALIGNMENT_TYPE = "Invalid alignment type.";
  this.INVALID_DIRECTION = "Invalid direction.";
  this.CONTAINER_SELECTED = "Container selected.";
  this.TEXTS_HAVE_DIFFERENT_DIMENSIONS = "Texts have different dimensions.";
  this.TEXTS_ARE_THE_SAME = "Texts are the same.";
  this.TEXT_PROPERTIES_SYNCED = "Text properties synced.";
  this.TEXTURE_CREATED_DDS_SUPPORT_ISSUE = "DDS textures are not supported in this device. Used "+compressedTextureFallbackFormat+" format instead.";
  this.COMPRESSED_TEXTURES_DO_NOT_SUPPORT = "Compressed textures do not support this function.";
  this.TEXTURE_CLONED = "Texture cloned for optimization.";
  this.TREE_TEXTURE = "|____@@1 @@2 -> @@3"
  this.THERE_ARE_NO_TEXTURES = "There are no textures.";
  this.NO_SUCH_LIGHTNING = "No such lightning.";
  this.STATUS_PENDING = "(PENDING)";
  this.STATUS_DOWNLOADING = "(DOWNLOADING)";
  this.STATUS_ERROR = "(ERROR)";
  this.STATUS_LOADED = "(LOADED)";
  this.GRID_SYSTEM_NOT_IN_SCENE = "Gridsystem is not inside the active scene.";
  this.AREA_NOT_IN_SCENE = "Area is not inside the active scene.";
  this.OBJECT_NOT_IN_SCENE = "Object is not inside the active scene.";
  this.MARKED_POINT_NOT_IN_SCENE = "Marked point is not inside the active scene.";
  this.OBJECT_NR_X_NOT_IN_SCENE = "Object nr. @@1 is not inside the active scene.";
  this.SOURCE_OBJECT_NOT_IN_SCENE = "Source object is not inside the active scene.";
  this.TARGET_OBJECT_NOT_IN_SCENE = "Target object is not inside the active scene.";
  this.MUZZLE_FLASH_NOT_IN_SCENE = "Muzzle flash is not inside the active scene.";
  this.PS_NOT_IN_SCENE = "Particle system is not inside the active scene.";
  this.TEXT_NOT_IN_SCENE = "Text not inside the active scene.";
  this.SPRITE_DESTROYED = "Sprite destroyed.";
  this.SPRITES = "Sprites";
  this.TEXTURES = "Textures";
  this.OBJECT_IS_A_COPY = "Object is a copy. Cannot export.";
  this.GENERATING_TEXTURE_ATLAS = "Generating texture atlas.";
  this.INITIALIZING_WORKERS = "Initializing workers.";
  this.NAME_CANNOT_EXCEED_X_CHARS = "Name cannot exceed @@1 characters.";
  this.CREATED_X_SURFACES = "Command executed for @@1 surfaces.";
  this.CREATED_X_AI_OBSTACLES = "Command executed for @@1 ai obstacles.";
  this.CREATED_X_BOXES = "Command executed for @@1 boxes.";
  this.CREATED_X_MASSES = "Command executed for @@1 masses.";
  this.CREATED_X_COPIES = "Command executed for @@1 copies.";
  this.CREATED_X_SPHERES = "Command executed for @@1 spheres.";
  this.CREATED_X_CYLINDERS = "Command executed for @@1 cylinders.";
  this.DESTROYED_X_TEXTURES = "Command executed for @@1 textures.";
  this.NO_SUCH_GRAPH = "No such graph.";
  this.NO_SUCH_GRAPH_IN_CURRENT_SCENE = "No such graph in current scene.";
  this.GRAPH_NOT_INSIDE_ACTIVE_SCENE = "Graph not inside the active scene.";
  this.GRAPH_DESTROYED = "Graph destroyed.";
  this.NO_GRAPHS_FOUND = "No graphs found.";
  this.ASTAR_CREATED = "AStar created.";
  this.ASTAR_DESTROYED = "AStar destroyed.";
  this.NO_SUCH_ASTAR_IN_CURRENT_SCENE = "No such AStar in current scene";
  this.NO_ASTARS_IN_THIS_SCENE = "No AStars in this scene.";
  this.COMMAND_EXECUTED_FOR_X_GRAPHS = "Command executed for @@1 graphs.";
  this.OBJECT_HAS_NO_MASS = "Object does not have a mass.";
  this.OBJECT_CANNOT_SET_MASS = "This object does not have a physics body as none of its children has a physics body.";
  this.PHYSICS_SIMPLIFIED = "Physics simplified.";
  this.PHYSICS_DESIMPLIFIED = "Physics desimplified.";
  this.NO_IMAGES_FOUND = "No images found.";
  this.COMMAND_EXECUTED_FOR_X_IMAGES = "Command executed for @@1 images.";
  this.NO_TEXTURE_FOUND = "No texture found.";
  this.NO_OBJECT_FOUND = "No object found.";
  this.PARTICLE_SYSTEMS = "Particle systems";
  this.PARTICLE_SYSTEM_POOLS = "Particle system pools.";
  this.MUZZLE_FLASHES = "Muzzleflashes.";
  this.NO_PARTICLE_SYSTEMS_CREATED = "No particle systems created.";
  this.NO_PARTICLE_SYSTEM_POOLS_CREATED = "No particle system pools created.";
  this.NO_MUZZLE_FLASHES_CREATED = "No muzzleflashes created.";
  this.SHADER_PRECISION_ADJUSTED = "Shader precision adjusted.";
  this.BEHAVIOR_ASSIGNED_TO_OBJECT = "Behavior assigned to object [@@1]. Unassign before deleting.";
  this.COMMAND_EXECUTED_FOR_X_OBJECTS = "Command executed for @@1 objects.";
  this.TEXTURE_PACK_MAPPED_TO_X_OBJECTS = "Command executed for @@1 objects.";
  this.TEXTURE_PACK_ALREADY_USED = "Texture pack already mapped, cannot be edited.";
  this.NO_GRID_SYSTEM_FOUND = "No grid system found.";
  this.DESTROYED_X_GRID_SYTEMS = "Command executed for @@1 grid systems.";
  this.NO_WALL_COLLECTION_FOUND = "No wall collection found."
  this.COMMAND_EXECUTED_FOR_X_WALL_COLLECTIONS = "Command executed for @@1 wall collections.";
  this.SCENE_DESTROYED = "Scene destroyed.";
  this.SCENE_IS_ACTIVE_CANNOT_DELETE = "Scene is active, cannot delete. Use switchScene command first.";
  this.CANNOT_DELETE_ENTRY_SCENE = "Cannot delete the entry scene.";
  this.NO_SCENES_FOUND = "No scenes found.";
  this.COMMAND_EXECUTED_FOR_X_SCENES = "Command executed for @@1 scenes.";
  this.COMMAND_EXECUTED_FOR_X_JUMPDESCRIPTORS = "Command executed for @@1 jump descriptors.";
  this.NO_JUMPDESCRIPTORS_FOUND = "No jump descriptors found.";
  this.FOG_IS_NOT_SET = "Fog is not set.";
  this.NO_SUCH_TEXTURE = "No such texture.";
  this.GRAPHS_IN_THIS_SCENE = "Graphs in this scene.";
  this.ASTARS_IN_THIS_SCENE = "AStars in this scene.";
  this.PATHS_IN_THIS_SCENE = "Paths in this scene.";
  this.NO_GRAPHS_IN_THIS_SCENE = "No graphs in this scene.";
  this.NO_PATHS_IN_THIS_SCENE = "No paths in this scene.";
  this.JUMPDESCRIPTORS_IN_THIS_SCENE = "Jump descriptors in this scene";
  this.NO_JUMPDESCRIPTORS_IN_THIS_SCENE = "No jump descriptors in this scene.";
  this.NO_SUCH_JUMPDESCRIPTOR = "No such jump descriptor.";
  this.JUMPDESCRIPTOR_NOT_IN_ACTIVE_SCENE = "Jump descriptor not inside the active scene.";
  this.JUMPDESCRIPTOR_DESTROYED = "Jump descriptor destroyed.";
  this.COMPRESSING_FONT = "Compressing font.";
  this.SCENE_CREATED = "Scene created.";
  this.NO_SUCH_SCENE = "No such scene.";
  this.CANNOT_ALIGN_SAME_CONTAINER = "Parent and child containers cannot be the same.";
  this.CONTAINER_IS_NOT_ALIGNED = "Container is not aligned.";
  this.CONTAINER_UNALIGNED = "Container unaligned.";
  this.CONTAINER_DESTROYED = "Container destroyed.";
  this.OBJECT_ALREADY_INSIDE_CONTAINER = "Object already inside container [@@1]. Use emptyContainer command first.";
  this.SCENE_IS_ALREADY_ACTIVE = "Scene is already active.";
  this.SCENE_SWITCHED = "Scene switched";
  this.ANIMATIONS_SYNCED = "Animations synced.";
  this.SOURCE_OBJECT_NOT_DEFINED = "Source object is not defined.";
  this.TARGET_OBJECT_NOT_DEFINED = "Target object is not defined.";
  this.SOURCE_AND_TARGET_OBJECTS_ARE_THE_SAME = "Source and target objects are the same.";
  this.OBJECTS_HAVE_DIFFERENT_TYPES = "Objects have different types.";
  this.OBJECTS_SYNCED = "Objects synced.";
  this.TEXTURE_DESTROYED = "Texture destroyed.";
  this.TEXTURE_NOT_READY = "Texture not ready.";
  this.CONTAINERS = "Containers";
  this.VIRTUAL_KEYBOARDS = "Virtual keyboards.";
  this.NO_VIRTUAL_KEYBOARDS_CREATED = "No virtual keyboards created.";
  this.NO_CONTAINERS_CREATED = "No containers created.";
  this.ERROR_HAPPENED_LOADING_TYPEFACE = "Error happened loading typeface.";
  this.ERROR_HAPPENED_COMPRESSING_FONT = "Error happened compressing font.";
  this.CANNOT_MAP_TEXTURE_TO_A_GLUED_OBJECT = "Cannot map texture to a glued object.";
  this.GLUED_OBJECTS_DO_NOT_SUPPORT_THIS_FUNCTION = "Glued objects do not support this function.";
  this.NO_TEXTURE_MAPPED_TO_OBJECT = "No texture mapped to object.";
  this.ENTRY_SCENE_SET = "Entry scene is @@1.";
  this.REPEAT_AMOUNT_MODIFIED = "Repeat amount modified.";
  this.WORKS_ONLY_IN_PREVIEW_MODE = "This command works only in preview mode.";
  this.DURATION_MUST_BE_A_NUMBER = "Duration must be a number.";
  this.NO_SUCH_EFFECT = "No such effect.";
  this.COMMAND_EXECUTED_FOR_X_CONTAINERS = "Command executed for @@1 containers.";
  this.NO_CONTAINERS_FOUND = "No containers found.";
  this.SIZEX_MUST_BE_A_NUMBER = "SizeX must be a number.";
  this.SIZEY_MUST_BE_A_NUMBER = "SizeY must be a number.";
  this.SIZEZ_MUST_BE_A_NUMBER = "SizeZ must be a number.";
  this.MASS_MUST_BE_A_NUMBER = "Mass must be a number.";
  this.INVALID_POSITION = "Invalid position.";
  this.POSITION_X_MUST_BE_A_NUMBER = "PositionX must be a number.";
  this.POSITION_Y_MUST_BE_A_NUMBER = "PositionY must be a number.";
  this.POSITION_Z_MUST_BE_A_NUMBER = "PositionZ must be a number.";
  this.PARTICLE_SYSTEM_CREATED = "Particle system created.";
  this.PARTICLE_SYSTEM_EDITED = "Particle system edited.";
  this.MUZZLEFLASH_CREATED = "Muzzle flash created.";
  this.MUZZLEFLASH_EDITED = "Muzzle flash edited.";
  this.OBJECT_MARKED_AS = "Object marked as @@1.";
  this.SPRITE_CREATED = "Sprite created.";
  this.CONTAINER_ALIGNED = "Container aligned.";
  this.PARENT_CONTAINER_DOES_NOT_EXIST = "Parent container does not exist.";
  this.CHILD_CONTAINER_DOES_NOT_EXIST = "Child container does not exist.";
  this.OBJECT_INTERSECTABLE = "Object set as intersectable. It means that the object can be collided with particles/particle systems and be picked with mouse.";
  this.OBJECT_UNINTERSECTABLE = "Object set as unintersectable. It means that the object cannot be collided with particles/particle systems and be picked with mouse.";
  this.A_NEW_BOX_TEST_STARTED = "A new box test started.";
  this.RADIUS_MUST_BE_A_NUMBER = "Radius must be a number.";
  this.A_NEW_SPHERE_TEST_STARTED = "A new sphere test started.";
  this.PHYSICS_TEST_TREE = "|____@@1 @@2 (@@3) -> @@4";
  this.PHYSICS_TESTS = "Physics tests"
  this.THERE_ARE_NO_PHYSICS_TESTS = "There are no physics tests.";
  this.PHYSICS_DEBUG_MODE_ON = "Physics debug mode: ON";
  this.PHYSICS_DEBUG_MODE_OFF = "Physics debug mode: OFF";
  this.ERROR_HAPPENED_COMPRESSING_TEXTURE_ATLAS = "Error happened compressing texture atlas.";
  this.AXIS_MUST_BE_ONE_OF_X_Y_Z = "Axis must be one of x, y, or z.";
  this.HEIGHT_MUST_BE_A_NUMBER = "Height must be a number.";
  this.AFTER_VIRTUAL_KEYBOARD_CREATION = "Press Done button to save virtual keyboard.";
  this.VIRTUAL_KEYBOARD_CREATED = "Virtual keyboard created.";
  this.VIRTUAL_KEYBOARD_EDITED = "Virtual keyboard edited.";
  this.NO_ANCHOR_GRIDS_SELECTED = "No anchor grid selected. Use setAnchor command first.";
  this.ONE_OF_THE_GRID_SELECTIONS_MUST_BE_THE_ANCHOR_GRID = "One of the grid selections must be the anchor grid.";
  this.AXIS_MUST_BE_X_OR_Z = "Axis must be x or z for this grid system.";
  this.AXIS_MUST_BE_Y_OR_Z = "Axis must be y or z for this grid system.";
  this.AXIS_MUST_BE_X_OR_Y = "Axis must be x or y for this grid system.";
  this.NO_AREAS_FOUND = "No areas found.";
  this.GRAPH_CONSTRUCTED = "Graph constructed.";
  this.GRAPH_CREATED = "Graph created.";
  this.NO_EDGE_ADDED = "No edge added. Cannot create graph.";
  this.EDGE_DOES_NOT_EXIST = "Edge does not exist.";
  this.MUST_HAVE_AT_LEAST_TWO_GRIDS_SELECTED = "Must have at least 2 grids selected.";
  this.AI_ENTITY_WITH_SAME_NAME_EXISTS = "An AI entity with the same name exists.";
  this.OBJECT_WILL_BE_USED_AS_AI_ENTITY = "Object will be used as an AI entity.";
  this.OBJECT_WONT_BE_USED_AS_AI_ENTITY = "Object won't be used as an AI entity.";
  this.NO_AVAILABLE_SLOT_FOR_THIS_LIGHT = "No available slot for this light.";
  this.VIRTUAL_KEYBOARD_DESTROYED = "Virtual keyboard destroyed.";
  this.NO_VIRTUAL_KEYBOARDS_FOUND = "No virtual keyboards found.";
  this.COMMAND_EXECUTED_FOR_X_VIRTUAL_KEYBOARDS = "Command executed for @@1 virtual keyboards.";
  this.COMMAND_EXECUTED_FOR_X_AREAS = "Command executed for @@1 areas.";
  this.MUST_HAVE_ONE_GRID_SELECTED = "Must have one grid selected.";
  this.MUST_HAVE_AT_LEAST_ONE_GRID_SELECTED = "Must have at least one grid selected.";
  this.NO_MATERIAL_FOUND = "No material found.";
  this.DESTROYED_X_MATERIALS = "Command executed for @@1 materials.";
  this.SCENE_ALREADY_HAS_A_STATIC_AMBIENT_LIGHT = "Scene already has a static ambient light.";
  this.SCENE_ALREADY_HAS_A_DYNAMIC_AMBIENT_LIGHT = "Scene already has a dynamic ambient light.";
  this.ANCHOR_SET = "Anchor set: @@1";
  this.INVALID_INDEX = "Invalid index.";
  this.TEST_RESTARTED = "Test restarted.";
  this.INVALID_PARAMETER = "Invalid parameter: @@1";
  this.ANIMATION_UPDATED = "Animation updated.";
  this.AXIS_MUST_BE_ONE_OF_S_T = "Axis must be one of s, t or st.";
  this.OBJECT_IS_ALREADY_SLIPPERY = "Object is already slippery.";
  this.SLIPPERINESS_ADJUSTED = "Slipperiness adjusted.";
  this.TEXT_ALLOCATED = "Text allocated.";
  this.OBJECT_WILL_BE_USED_AS_FPS_WEAPON = "Object will be used as FPS weapon. Use fpsWeaponAlignment CLI command to configure the weapon alignment.";
  this.OBJECT_IS_NOT_MARKED_AS_FPS_WEAPON = "Object is not marked as an FPS weapon.";
  this.TEXTS = "Texts";
  this.TEXTURE_ATLAS_MAX_ALLOWED_SIZE_EXCEEDED = "Max allowed size for a texture atlas exceeded.";
  this.TEXTURE_PACK_USED_IN_VIRTUAL_KEYBOARD = "Texture pack used in virtual keyboard [@@1]. Cannot delete.";
  this.OBJECT_IS_ALREADY_NOT_SLIPPERY = "Slipperiness is already off for the object.";
  this.SLIPPERINESS_STATE_MUST_BE_ON_OR_OFF = "Slipperiness state must be on or off."
  this.MIRROR_STATE_MUST_BE_ON_OR_OFF = "Mirror state must be on or off.";
  this.MIRRORED_REPEAT_SET = "Mirrored repeat set @@1 for @@2.";
  this.BOX_CREATED = "Box created.";
  this.AN_ERROR_HAPPENED_CHOOSE_ANOTHER_NAME = "An error happened. Choose another name.";
  this.ERROR_HAPPENED_COMPRESSING_TEXTURE = "Error happened compressing texture @@1. Provide a JPG alternative.";
  this.DYNAMIC_TEXTURE_FOLDER_PREPARED = "Dynamic texture folder prepared.";
  this.MUZZLE_FLASH_USED_IN = "Muzzleflash used in FPS weapon @@1. Cannot destroy.";
  this.MUZZLE_FLASH_DESTROYED = "Muzzleflash destroyed."
  this.HEIGHT_CANNOT_BE_0 = "Height cannot be 0.";
  this.WALL_COLLECTION_CREATED = "Wall collection created.";
  this.MASS_CREATED = "Mass created.";
  this.JUMPDESCRIPTOR_ALREADY_INSERTED_TO_THE_PATH = "Jump descriptor is already inserted into the path.";
  this.JUMPDESCRIPTOR_ALREADY_INSERTED_TO_THE_GRAPH = "Jump descriptor is already inserted into the graph.";
  this.JUMP_DESCRIPTOR_INSERTED_TO_A_PATH = "Jump descriptor is inserted to a path. Cannot delete.";
  this.JUMP_DESCRIPTOR_INSERTED_TO_A_GRAPH = "Jump descriptor is inserted to a graph. Cannot delete.";
  this.LIGHTNING_DESTROYED = "Lightning destroyed.";
  this.WALL_COLLECTIONS = "Wall collections";
  this.TREE_WALL_COLLECTIONS = "|____@@1: OUTLINE COLOR -> @@2";
  this.PHYSICS_UNSIMPLIFIED = "Physics unsimplified.";
  this.CONTAINER_IS_EMPTY = "Container is empty.";
  this.CONTAINER_EMPTIED = "Container is emptied.";
  this.PHYSICS_IS_NOT_SIMPLIFIED = "Object physics is not simplified.";
  this.THERE_ARE_NO_CREATED_WALL_COLLECTIONS = "There are no created wall collections.";
  this.WALL_COLLECTION_DESTROYED = "Wall collection destroyed.";
  this.NO_SUCH_WALL_COLLECTION = "No such wall collection.";
  this.CAMERA_RESET = "Camera reset.";
  this.THIS_FUNCTION_IS_NOT_SUPPORTED_IN_YOUR_BROWSER = "This function is not supported in your browser.";
  this.NAME_CANNOT_BE_EMPTY = "Name cannot be empty.";
  this.DIALOG_OPENED_CHOOSE_AN_IMAGE = "Dialog opened. Choose an image to upload.";
  this.LOADING_IMAGE = "Loading image.";
  this.IMAGE_CREATED = "@@1 created.";
  this.NO_FILE_SELECTED_OPERATION_CANCELLED = "No file selected, operation canceled.";
  this.IMAGES = "Images";
  this.CROSSHAIR_CREATED = "Crosshair created.";
  this.CROSSHAIR_EDITED = "Crosshair edited.";
  this.CROSSHAIR_DESTROYED = "Crosshair destroyed.";
  this.OBJECTS_HAVE_TOO_MANY_FACES = "Objects have too many faces. Cannot glue.";
  this.TOO_MANY_GRIDS = "Too many grids.";
  this.NO_UPLOADED_IMAGES = "No uploaded images.";
  this.SPECULAR_TEXTURE_MAPPED = "Specular texture mapped.";
  this.ENVIRONMENT_TEXTURE_MAPPED = "Environment texture mapped";
  this.AMBIENT_OCCULSION_TEXTURE_MAPPED = "Ambient occulsion texture mapped";
  this.ALPHA_TEXTURE_MAPPED = "Alpha texture mapped";
  this.STEERING_BEHAVIOR_CREATED = "Steering behavior created.";
  this.TEXTURE_MAPPED = "Texture mapped.";
  this.TREE_LIGHTS = "|____@@1 @@2";
  this.SELECTED = "Selected @@1.";
  this.JUMPDESCRIPTOR_INSERTED_INTO_THE_PATH = "Jumpdescriptor inserted into the path.";
  this.JUMPDESCRIPTOR_INSERTED_INTO_THE_GRAPH = "Jumpdescriptor inserted into the graph.";
  this.JUMPDESCRIPTOR_IS_NOT_ON_THE_PATH = "Jumpdescriptor is not on the path.";
  this.JUMPDESCRIPTOR_IS_NOT_ON_THE_GRAPH = "Jumpdescriptor takeoff/landing points are not inside this graph.";
  this.NO_SUCH_OBSTACLE = "No such obstacle.";
  this.NO_SUCH_OBSTACLE_IN_CURRENT_SCENE = "No such obstacle in the current scene.";
  this.NO_ASTARS_FOUND = "No AStars found.";
  this.NO_SUCH_MASS = "No such mass.";
  this.MASS_DESTROYED = "Mass destroyed.";
  this.COMMAND_EXECUTED_FOR_X_ASTARS = "Command executed for @@1 AStars.";
  this.OBSTACLE_NOT_IN_ACTIVE_SCENE = "Obstacle not in active scene";
  this.OBSTACLE_DESTROYED = "Obstacle destroyed.";
  this.AI_DEBUG_MODE_SWITCHED_ON = "AI debug mode switched on.";
  this.AI_DEBUG_MODE_SWITCHED_OFF = "AI debug mode switched off.";
  this.OBJECT_WILL_BE_AFFECTED_BY_LIGHTS = "Object will be affected by lights.";
  this.OBJECT_WONT_BE_AFFECTED_BY_LIGHTS = "Object will not be affected by lights.";
  this.NORMAL_MAPS_ARE_NOT_SUPPROTED = "Normal maps are not supported by basic materials.";
  this.SPECULAR_MAPS_ARE_NOT_SUPPORTED = "Specular maps are not supported by basic materials.";
  this.NORMAL_TEXTURE_MAPPED = "Normal texture mapped.";
  this.USE_GUI_TO_ADD_EDGES = "Use the GUI to add edges to graph.";
  this.USE_GUI_TO_CREATE_STEERING_BEHAVIORS = "Use the GUI to create steering behaviors.";
  this.USE_GUI_TO_CREATE_JUMP_DESCRIPTORS = "Use the GUI to create jump descriptors.";
  this.EDGE_ALREADY_EXISTS = "Edge already exists.";
  this.EDGE_ADDED = "Edge added: @@1 -> @@2";
  this.EDGE_REMOVED = "Edge removed: @@1 -> @@2";
  this.EDGES_REMOVED = "@@1 edge(s) removed";
  this.NO_SUCH_EDGE_IN_THE_GRAPH = "No such edge in the graph.";
  this.NO_EDGES_FOUND_IN_THE_GRAPH = "No edges found in the graph.";
  this.EDGE_MUST_CONTAIN_DIFFERENT_VERTICES = "Edge must contain different vertices.";
  this.EMISSIVE_MAPS_ARE_NOT_SUPPORTED = "Emissive maps are not supported by basic materials.";
  this.EMISSIVE_TEXTURE_MAPPED = "Emissive texture mapped.";
  this.DIRECTORY_NAME_CANNOT_BE_EMPTY = "Directory name must not be empty.";
  this.FILE_EXTENSION_CANNOT_BE_EMPTY = "File extension must not be empty.";
  this.TAKEOFF_POINT_DOES_NOT_EXIST = "Takeoff point does not exist.";
  this.LANDING_POINT_DOES_NOT_EXIST = "Landing point does not exist.";
  this.TAKEOFFPOINT_IS_NOT_IN_THE_ACTIVE_SCENE = "Takeoff point is not in the active scene.";
  this.LANDING_POINT_IS_NOT_IN_THE_ACTIVE_SCENE = "Landing point is not in the active scene.";
  this.JUMP_DESCRIPTOR_CREATED = "Jump descriptor created.";
  this.TAKEOFF_POINT_AND_LANDING_POINT_ARE_THE_SAME = "Takeoff point and landing point are the same.";
  this.TEXTURE_PACK_CREATED = "Texture pack created.";
  this.TEXTURE_PACK_EDITED = "Texture pack edited.";
  this.TEXTURE_PACKS = "Texture packs";
  this.INCLUDED_SCRIPTS = "Included scripts";
  this.CROSSHAIRS = "Crosshairs";
  this.LIGHTNINGS = "Lightnings";
  this.SCENES = "Scenes";
  this.NO_TEXTURE_PACK_FOUND = "No texture pack found.";
  this.COMMAND_EXECUTED_FOR_X_TEXTURES = "Command executed for @@1 textures.";
  this.COMMAND_EXECUTED_FOR_X_TEXTURE_PACKS = "Command executed for @@1 texture packs.";
  this.COMMAND_EXECUTED_FOR_X_SKYBOXES = "Command executed for @@1 skyboxes.";
  this.NO_SKYBOX_FOUND = "No skybox found.";
  this.NO_SCRIPTS_FOUND = "No scripts found.";
  this.BEHAVIOR_IS_NOT_ASSIGNED_TO_THIS_OBJECT = "Steerable is not assigned to this object.";
  this.BEHAVIOR_UNASSIGNED = "Behavior unassigned.";
  this.COMMAND_EXECUTED_FOR_X_SCRIPTS = "Command executed for @@1 scripts.";
  this.COMMAND_EXECUTED_FOR_X_MARKED_POINTS = "Command executed for @@1 marked points.";
  this.MARKED_X_POINTS = "Command executed for @@1 points.";
  this.NO_TEXTURE_PACKS_CREATED = "No texture packs created.";
  this.NO_SCRIPTS_INCLUDED = "No scripts included.";
  this.NO_CROSSHAIRS_CREATED = "No crosshairs created.";
  this.NO_LIGHTNINGS_CREATED = "No lightnings created.";
  this.COMMAND_EXECUTED_FOR_X_CROSSHAIRS = "Command executed for @@1 crosshairs.";
  this.COMMAND_EXECUTED_FOR_X_LIGHTNINGS = "Command executed for @@1 lightnings.";
  this.NO_CROSSHAIRS_FOUND = "No crosshairs found.";
  this.NO_LIGHTNINGS_FOUND = "No lightnings found.";
  this.NO_SUCH_TEXTURE_PACK = "No such texture pack.";
  this.MUST_SPECIFY_AT_LEAST_ONE_POINT = "Must specify at least one marked point.";
  this.MUST_SPECIFY_AT_LEAST_TWO_POINTS = "Must specify at least two marked points.";
  this.POINT_X_DOES_NOT_EXIST = "Point#@@1 does not exist.";
  this.POINT_X_NOT_IN_ACTIVE_SCENE = "Point#@@1 is not inside the active scene.";
  this.GRAPH_X_DOES_NOT_EXIST = "Graph#@@1 does not exist.";
  this.GRAPH_X_NOT_IN_ACTIVE_SCENE = "Graph#@@1 is not inside the active scene.";
  this.MUST_MERGE_AT_LEAST_2_GRAPHS = "Must merge at least 2 graphs.";
  this.GRAPHS_MERGED = "Graphs merged.";
  this.NO_SUCH_TEXT = "No such text.";
  this.LIGHT_ADDED = "Light added.";
  this.LIGHT_REMOVED = "Light removed.";
  this.ACCEPTED_TEXTURE_SIZE = "Accepted texture size";
  this.CANNOT_SET_TEXTURE_SIZE_AFTER = "Cannot set accepted texture size after texture pack creation. Delete the texture packs first.";
  this.TEXTURE_COMPRESSION_ERROR = "Error happened while compressing texture pack @@1. Try using smaller PNGs.";
  this.TEXTURE_COMPRESSION_ENCODE_ERROR = "Error happened while compressing @@1 texture of @@2.\nTry providing a JPEG alternative for this texture under the texture pack folder.";
  this.TEXTURE_PACK_NOT_USABLE = "Texture pack not usable.";
  this.TEXTURE_PACK_MAPPED = "Texture pack mapped.";
  this.TEXTURE_PACK_DESTROYED = "Texture pack destroyed.";
  this.TEXTURE_PACK_REFRESHED = "Texture pack refreshed.";
  this.HEIGHT_TEXTURE_MAPPED = "Height texture mapped.";
  this.MAPS_RESET = "Maps reset.";
  this.COUNT_MUST_BE_A_NUMBER = "Count must be a number.";
  this.COUNT_MUST_BE_GREATER_THAN_1 = "Count must be greater than 1.";
  this.OBJECT_SEGMENTED = "Object segmented.";
  this.FOLDER_DOES_NOT_EXIST_UNDER_DYNAMIC_TEXTURES = "Folder does not exist under dynamic_textures/";
  this.RAMPS_DO_NOT_SUPPORT_THIS_FUNCTION = "Ramps do not support this function.";
  this.SPHERES_DO_NOT_SUPPORT_THIS_FUNCTION = "Spheres do not support this function.";
  this.SURFACES_DO_NOT_SUPPORT_THIS_FUNCTION_UNLESS = "Surfaces do not support this function unless they are on XZ grid systems.";
  this.STATUS_MUST_BE_ONE_OF = "Status must be one of show or hide.";
  this.GUI_IS_ALREADY_HIDDEN = "GUI is already hidden.";
  this.GUI_CLOSED = "GUI closed.";
  this.GUI_IS_ALREADY_VISIBLE = "GUI is already visible.";
  this.GUI_OPENED = "GUI opened.";
  this.SOURCESPRITE_DOES_NOT_EXIST = "sourceSprite does not exist.";
  this.TARGETSPRITE_DOES_NOT_EXIST = "targetSprite does not exist.";
  this.TARGETSPRITE_NOT_IN_ACTIVE_SCENE = "targetSprite is not inside active scene.";
  this.SPRITE_SIZE_ADJUSTED = "Sprite size adjusted.";
  this.CELLSIZE_MUST_BE_A_NUMBER = "Cellsize must be a number.";
  this.OFFSETX_MUST_BE_A_NUMBER = "OffsetX must be a number.";
  this.OFFSETY_MUST_BE_A_NUMBER = "OffsetY must be a number.";
  this.OFFSETZ_MUST_BE_A_NUMBER = "OffsetZ must be a number.";
  this.SKYBOX_CREATED = "Skybox created.";
  this.SKYBOX_EDITED = "Skybox edited.";
  this.CANNOT_CREATE_MUZZLEFLASH_COLLIDABLE_PS = "Cannot create muzzleflash from a collidable particle system.";
  this.CANNOT_CREATE_MUZZLEFLASH_COLLIDABLE_PARTICLES = "Cannot create muzzleflash from a particle system with collidable particles.";
  this.SKYBOXES = "Skyboxes";
  this.PIVOT_SET = "Pivot set.";
  this.ASTAR_USED_IN_BEHAVIOR = "AStar used in PathFollowingBehavior [@@1]. Cannot destroy.";
  this.NO_SKYBOXES_CREATED = "No skyboxes created.";
  this.NO_SUCH_SKYBOX = "No such skybox.";
  this.SKYBOX_NOT_USABLE = "Skybox not usable. Use the command printSkyboxInfo for the details.";
  this.SKYBOX_MAPPED = "Skybox mapped.";
  this.SKYBOX_DESTROYED = "Skybox destroyed.";
  this.NO_SKYBOX_MAPPED = "No skybox mapped. Use mapSkybox command first.";
  this.NO_FOG_SET = "No fog set. Use setFog command first.";
  this.SKYBOX_NOT_VISIBLE = "Skybox not visible.";
  this.SKYBOX_HIDDEN = "Skybox hidden.";
  this.AI_OBSTACLES_IN_THIS_SCENE = "AI Obstacles in This Scene";
  this.NO_AI_OBSTACLES_CREATED = "NO AI obstacles created.";
  this.SKYBOX_ALREADY_VISIBLE = "Skybox already visible.";
  this.SKYBOX_SHOWN = "Skybox shown.";
  this.MUST_HAVE_AT_LEAST_TWO_MARKED_POINTS_INSIDE_SCENE = "Must have at least two marked points inside the active scene.";
  this.SKYBOX_NOT_DEFINED = "Skybox not defined.";
  this.AMOUNT_MUST_HAVE_A_NUMERICAL_VALUE = "Amount must have a numerical value.";
  this.SKYBOX_SCALE_ADJUSTED = "Skybox scale adjusted.";
  this.PHYSICS_DISABLED = "Physics disabled for object.";
  this.PHYSICS_ENABLED = "Physics enabled for object.";
  this.DOWNLOAD_PROCESS_INITIATED = "Download process initiated.";
  this.CHOOSE_A_FILE_TO_UPLOAD = "Dialog opened. Choose a file to upload.";
  this.LOADING_FILE = "Loading file.";
  this.BUILDING_PROJECT = "Building project.";
  this.PROJECT_LOADED = "Project loaded.";
  this.FONT_CREATED = "Font created.";
  this.ERROR_CREATING_FONT = "An error happened creating font. Make sure @@1 exists.";
  this.LOADING_SHADERS = "Loading shaders.";
  this.LOADING_PROJECT = "Loading project.";
  this.LOADING_SCRIPTS = "Loading scripts.";
  this.LOADING_FONT = "Loading font.";
  this.LOADING = "Loading.";
  this.COMPRESSING_TEXTURE = "Compressing texture.";
  this.TEXTURES_COMPRESSED = "Textures compressed.";
  this.CONFIGURING_AREA = "Configuring area.";
  this.CONFIGURING_AREAS = "Configuring areas.";
  this.AREA_CONFIGURED = "Area configured. Please check the area for manual corrections.";
  this.AREAS_CONFIGURED = "Areas configured. Please check the areas for manual corrections.";
  this.PROJECT_FAILED_TO_LOAD = "Project failed to load: @@1";
  this.NOTHING_TO_UNDO = "Nothing to undo.";
  this.OK = "Ok.";
  this.GRAPH_USED_IN_ASTAR = "Graph used in AStar [@@1] cannot destroy.";
  this.NOTHING_TO_REDO = "Nothing to redo.";
  this.OBJECT_SELECTED = "@@1 selected.";
  this.MASS_MUST_BE_A_POSITIVE_NUMBER = "Mass must be a positive number.";
  this.MASS_SET = "Mass set.";
  this.INVALID_EXPRESSION = "Invalid expression.";
  this.NO_VALID_TEXTURE_PACK_FOLDER = "There are no valid texture pack folders under texture_packs folder.";
  this.NO_VALID_SKYBOX_FOLDER = "There are no valid skybox folders under skybox root folder.";
  this.NO_VALID_FONTS = "There are no valid TTF files under fonts root folder.";
  this.NO_FONTS_CREATED = "No fonts created.";
  this.NO_SUCH_VIRTUAL_KEYBOARD = "No such virtual keyboard.";
  this.VIRTUAL_KEYBOARD_NOT_IN_ACTIVE_SCENE = "Virtual keyboard not in active scene.";
  this.RADIAN_MUST_BE_A_NUMBER = "Radian must be a number.";
  this.OBJECT_ROTATED = "Object rotated.";
  this.TEXT_DESTROYED = "Text destroyed.";
  this.OPERATION_CANCELLED = "Operation cancelled.";
  this.SCRIPT_CREATED = "Script created.";
  this.NO_SUCH_SCRIPT = "No such script.";
  this.SCRIPT_ALREADY_RUNNING = "Script already running.";
  this.SCRIPT_STARTED_RUNNING = "Script started running.";
  this.SCRIPT_IS_NOT_RUNNING = "Script is not running.";
  this.SCRIPT_STOPPED = "Script stopped.";
  this.NO_SCRIPTS_CREATED = "No scripts created.";
  this.PARTICLE_SYSTEM_USED_IN_A_POOL = "Particle system is used in a pool. Cannot delete.";
  this.PARTICLE_SYSTEM_USED_IN_A_MUZZLEFLASH = "Particle system is used in a muzzle flash. Cannot delete.";
  this.PARTICLE_SYSTEM_DESTROYED = "Particle system destroyed.";
  this.PARTICLE_SYSTEM_POOL_DESTROYED = "Particle system pool destroyed.";
  this.SCRIPTS = "Scripts";
  this.TREE_SCRIPTS = "|____ @@1 -> @@2";
  this.SCRIPT_MODIFIED = "Script modified.";
  this.SCRIPT_DESTROYED = "Script destroyed.";
  this.NEAR_MUST_BE_A_NUMBER = "Near must be a number.";
  this.FAR_MUST_BE_A_NUMBER = "Far must be a number.";
  this.FOG_SET = "Fog set. Fogs are visible only in the preview mode.";
  this.FOG_INFO = "Fog info"
  this.FOG_REMOVED = "Fog removed from the scene.";
  this.ATLAS_TEXTURE_SIZE = "Atlas texture size";
  this.ATLAS_TEXTURE_SIZE_NOT_SET = "Atlas texture size not set.";
  this.TEXTURE_SIZE_CANNOT_EXCEED = "Texture size cannot exceed "+MAX_TEXTURE_SIZE;
  this.CANNOT_GLUE_OBJECTS_WITH_DIFFERENT_MATERIAL_TYPES = "Cannot glue objects with different material types.";
  this.MUST_GLUE_AT_LEAST_2_OBJECTS = "Must glue at least 2 objects.";
  this.OBJECT_NR_DOES_NOT_EXIST = "Object #@@1 does not exist.";
  this.OBJECT_IN_MOTION = "Object #@@1 is in motion. Use switchView command first to reset the animation.";
  this.OBJECTS_GLUED_TOGETHER = "Objects glued together.";
  this.OBJECT_DOES_NOT_HAVE_A_PIVOT = "Object does not have a pivot point.";
  this.OBJECT_HAS_A_ROTATION_PIVOT_NO_LOCAL = "Object has a rotation pivot. Cannot enable local rotation mode.";
  this.OBJECT_HAS_LOCAL_ROTATION_CANNOT_SET_PIVOT = "Object has local rotation mode enabled. Cannot set rotation pivot.";
  this.PIVOT_UNSET = "Pivot unset.";
  this.INVALID_SYNTAX = "Invalid syntax.";
  this.OBJECT_DETACHED = "Object detached.";
  this.POINT_MARKED = "Point marked.";
  this.NO_SUCH_POINT = "No such point.";
  this.POINT_UNMARKED = "Point unmarked.";
  this.NO_MARKED_POINTS = "No marked points.";
  this.NO_MARKED_POINTS_FOUND = "No marked points found.";
  this.PROJECT_BUILDED = "Project builded. Deployment folder is: @@1";
  this.MARKED_POINTS = "Marked points";
  this.TREE_POINT = "|____ @@1: (@@2, @@3, @@4)";
  this.JUMP_IS_ACHIEVABLE_FOR_STEERABLE = "The jump is achievable for steerable [@@1].";
  this.JUMP_IS_UNACHIEVABLE_FOR_STEERABLE = "The jump is unachivable for steerable [@@1].";
  this.MARKED_POINTS_TOGGLED = "Marked points toggled.";
  this.CENTERX_MUST_BE_A_NUMBER = "CenterX must be a number.";
  this.CENTERY_MUST_BE_A_NUMBER = "CenterY must be a number.";
  this.CENTERZ_MUST_BE_A_NUMBER = "CenterZ must be a number.";
  this.PADDING_MUST_BE_A_NUMBER = "padding must be a number.";
  this.PADDING_MUST_BE_POSITIVE = "padding must be greater than zero."
  this.PADDING_ADDED_TO_TEXTURE = "Padding added to texture.";
  this.AXIS_MUST_BE_ONE_OF_XY_YZ_XZ = "Axis must be one of XZ, XY or YZ.";
  this.CLICKED_ON = "Clicked on: @@1";
  this.NO_OBJECT_SELECTED_FOR_TEXTURE_ADJUSTMENT = "No object selected for texture adjustment.";
  this.NO_OBJECT_SELECTED_FOR_OPACITY_ADJUSTMENT = "No object selected for opacity adjustment.";
  this.OPACITY_ADJUSTED = "Opacity adjusted.";
  this.SHININESS = "Shininess: @@1";
  this.MAX_NUMBER_OF_SEGMENTS_ALLOWED = "Maximum number of allowed segments is @@1.";
  this.NO_OBJECTS_SELECTED_TO_ADJUST_SHININESS = "No objects selected to adjust shininess.";
  this.HEIGHT_MAP_SCALE = "Height map scale: @@1";
  this.NO_HEIGHT_TEXTURE_MAPPED_TO_THIS_OBJECT = "No height texture mapped to this object.";
  this.NO_OBJECTS_SELECTED_TO_ADJUST_HEIGHT_MAP_SCALE = "No objects selected to adjust height map scale.";
  this.HEIGHT_MAP_BIAS = "Height map bias: @@1";
  this.GUI_IS_ALREADY_OPEN_FOR_THIS_OBJECT = "GUI is already open for this object.";
  this.PRESS_DONE_BUTTON_TO = "Press Done button to quit FPS weapon alignment mode.";
  this.AFTER_PS_CREATION = "Press Done button to create particle system.\nUse mouse wheel/mouse drag to rotate.\nUp/Down or W/S (Z/S - French keyboard) to zoom in/out.";
  this.AFTER_MUZZLE_FLASH_CREATION = "Press Done button to create muzzle flash.\nUse mouse wheel/mouse drag to rotate.\nUp/Down or W/S (Z/S - French keyboard) to zoom in/out.";
  this.AFTER_TEXTURE_PACK_CREATION = "Press Done button to create texture pack.\nUse mouse wheel/mouse drag to rotate.\nUp/Down or W/S (Z/S - French keyboard) to zoom in/out.";
  this.AFTER_SKYBOX_CREATION = "Press Done button to create skybox.\nUse mouse wheel/mouse drag to rotate.";
  this.AFTER_FONT_CREATION = "Press Done button to create font.\nUp/Down or W/S (Z/S - French keyboard) to zoom in/out.";
  this.AFTER_FOG_CREATION = "Press Done button to close.";
  this.AFTER_CROSSHAIR_CREATION = "Press Done button to create crosshair.";
  this.AFTER_SCRIPT_CREATION = "Press Done button to close.";
  this.AFTER_ANIMATION_CREATION = "Press Done button to close.\nUse mouse wheel/mouse drag to rotate.\nUp/Down or W/S (Z/S - French keyboard) to zoom in/out.";
  this.AFTER_ANIMATION_CREATION_FPS_WEAPON = "Press Done button close.";
  this.AFTER_LIGHTNING_CREATION = "Press Done button to create lightning.\nUse mouse wheel/mouse drag to rotate.\nUp/Down or W/S (Z/S - French keyboard) to zoom in/out.";
  this.ANIMATION_NAME_MUST_BE_A_NON_EMPTY_STRING = "Animation name must be a non empty string.";
  this.ANIMATION_NAME_MUST_BE_UNIQUE = "Animation name must be unique.";
  this.DONE = "Done.";
  this.GS_CREATION_ERROR_1 = "sizeX and sizeZ must be greater than zero.";
  this.GS_CREATION_ERROR_2 = "sizeX is not multiple of cellSize";
  this.GS_CREATION_ERROR_3 = "sizeZ is not multiple of cellSize";
  this.GS_CREATION_ERROR_4 = "name must be unique.";
  this.GS_CREATION_ERROR_5 = "cellSize is less than minimum size allowed ("+MIN_CELLSIZE_ALLOWED+")";
  this.GS_CREATION_ERROR_6 = "Too many grids in a scene. Maximum "+MAX_GRIDS_ALLOWED+" allowed.";
  this.GS_CREATED = "Grid system created.";
  this.GS_CROPPED = "Grid system cropped and added to buffer.";
  this.RAMP_CREATED = "Ramp created. Anchor reset.";
  this.LIGHTNING_CREATED = "Lightning created.";
  this.LIGHTNING_EDITED = "Lightning edited.";
  this.PHY_TEST_KEY_NOT_UNIQUE = "Test key not unique. Test cancelled.";
  this.SPHERE_CAN_HAVE_MINIMUM_8_SEGMENTS = "Spheres can have minimum 8 segments.";
  this.SKYBOXINFO_HEADER = "Skybox info";
  this.SKYBOXINFO_NAME = "NAME: @@1";
  this.SKYBOXINFO_DIRNAME = "DIR NAME: @@1";
  this.SKYBOXINFO_FILEEXTENSION = "FILE EXTENSION: @@1";
  this.SKYBOXINFO_FILEPATHS = "FILE PATHS";
  this.SKYBOXINFO_TREE_BACK ="|____back: @@1";
  this.SKYBOXINFO_TREE_DOWN = "|____down: @@1";
  this.SKYBOXINFO_TREE_FRONT = "|____front: @@1";
  this.SKYBOXINFO_TREE_LEFT = "|____left: @@1";
  this.SKYBOXINFO_TREE_RIGHT = "|____right: @@1";
  this.SKYBOXINFO_TREE_UP = "|____up: @@1";
  this.SKYBOXINFO_TEXTURES = "TEXTURES";
  this.TEXTUREPACK_INFO_TREE_DIFFUSE = "|____diffuse: @@1";
  this.TEXTUREPACK_INFO_TREE_ALPHA = "|____alpha: @@1";
  this.TEXTUREPACK_INFO_TREE_AO = "|____ambient occulsion: @@1";
  this.TEXTUREPACK_INFO_TREE_EMISSIVE = "|____emissive: @@1";
  this.TEXTUREPACK_INFO_TREE_ENVIRONMENT = "|____environment: @@1";
  this.TEXTUREPACK_INFO_TREE_NORMAL = "|____normal: @@1";
  this.TEXTUREPACK_INFO_TREE_SPECULAR = "|____specular: @@1";
  this.TEXTUREPACK_INFO_TREE_HEIGHT = "|____height: @@1";
  this.TEXTUREPACK_TEXTURES = "TEXTURES";
  this.TEXTUREPACK_FILEPATHS = "FILE PATHS";
  this.TEXTUREPACK_NAME = "NAME: @@1";
  this.TEXTUREPACK_DIRNAME = "DIR NAME: @@1";
  this.TEXTUREPACK_FILEEXTENSION = "FILE EXTENSION: @@1";
  this.TEXTUREPACK_INFO_HEADER = "Texture pack info";
  this.FAILED_TO_LOAD_SCRIPT = "Failed to load script @@1 from file path @@2.";
  this.SCRIPT_UPLOADED = "Script uploaded.";
  this.SCENE_LOADED = "Scene loaded.";
  this.JUMP_DESCRIPTOR_UPDATED = "Jump descriptor updated.";
  this.NO_SUCH_DYNAMIC_TEXTURE_FOLDER = "No such dynamic texture folder.";
  this.DYNAMIC_TEXTURE_FOLDER_DESTROYED = "Dynamic texture folder destroyed.";
  this.NO_DYNAMIC_TEXTURE_FOLDERS_FOUND = "No dynamic texture folders found.";
  this.COMMAND_EXECUTED_FOR_X_DYNAMIC_TEXTURE_FOLDERS = "Command executed for @@1 dynamic texture folders.";
  this.DYNAMIC_TEXTURE_FOLDERS = "Dynamic texture folders.";
  this.NO_DYNAMIC_TEXTURE_FOLDERS_CREATED = "No dynamic texture folders created.";
  this.AN_UNEXPECTED_ERROR_HAPPENED = "An unexpected error happened.";
  this.AREA_CONFIGURATIONS_ARE_ALREADY_STOPPED = "Area configurations handling is already stopped.";
  this.AREA_CONFIGURATIONS_ARE_ALREADY_STARTED = "Area configurations handling is already started.";
  this.AREA_CONFIGURATIONS_ARE_STOPPED = "Area configurations handling is stopped.";
  this.AREA_CONFIGURATIONS_ARE_STARTED = "Area configurations handling is started.";
  this.THIS_SCRIPT_IS_UPLOADED = "This script is uploaded from the local file system. Make your modifications locally."
  this.PREPARING_OBJECT = "Creating KTree of @@1";
  this.SERVER_WS_URL_SET = "Server WS URL set.";
  this.SERVER_WS_URL_IS_NOT_SET = "Server WS URL is not set.";
  this.SERVER_WS_URL_IS = "Server WS URL is: @@1.";
  this.SERVER_WS_URL_RESET = "Server WS URL reset.";
  this.OBJECT_MUST_BE_IN_THE_SAME_GRIDSYSTEM = "Glued objects must be in the same grid system.";
  this.CREATING_X_GRIDS = "Creating @@1 grids.";
  this.TEXTURE_REPEAT_U_MUST_BE_A_POSITIVE_NUMBER = "repeatU must be a positive number.";
  this.TEXTURE_REPEAT_V_MUST_BE_A_POSITIVE_NUMBER = "repeatV must be a positive number.";
  this.WORKS_ONLY_IN_DESIGN_MODE = "This command works only in Design mode.";
  this.INVALID_CHARACTER_IN_OBJECT_NAME = "Invalid character in object name.";
  this.INVALID_CHARACTER_IN_NAME = "Invalid character in name.";
  this.PARAMETER_MUST_BE_ON_OFF = "Parameter must be on or off.";
  this.OBJECT_IS_ALREADY_USED_AS_AI_ENTITY = "Object is already used as an AI entity.";
  this.OBJECT_IS_ALREADY_NOT_USED_AS_AI_ENTITY = "Object is already not used as an AI entity.";
  this.WORKS_ONLY_FOR_2D_TEXTS = "This command works only for 2D texts.";
  this.FOR_MOBILE = "Application is @@1 for mobile devices.";
  this.CANNOT_SIMPLIFY_PHYISCS_DYNAMIC_OBJECTS = "Cannot simplify physics of dynamic objects.";
  this.CANNOT_SET_MASS_FOR_SIMPLIFIED_OBJECTS = "Cannot set mass for objects with simplified physics.";
  this.ALREADY_FOR_MOBILE = "Application is already @@1 for mobile devices.";
  this.ENABLED = "enabled";
  this.BEHAVIOR_USED_IN_COMBINED_STEERING_BEHAVIOR = "Behavior used in a combined steering behavior. Cannot delete.";
  this.PROTOCOL_DEFINITION_FILE_DOES_NOT_EXIST = "Protocol definition file does not exist: @@1";
  this.PROTOCOL_DEFINITION_FILE_SET = "Protocol definition file set.";
  this.PROTOCOL_DEFINITION_FILE_RESET = "Protocol definition file reset.";
  this.PROTOCOL_DEFINITION_FILE_IS_NOT_SET = "Protocol definition file is not set.";
  this.PROTOCOL_DEFINITION_WILL_BE_LOADED_FROM = "Protocol definition file will be loaded from: @@1";
  this.OBJECT_HAS_CHILD_ROTATION_SET = "Object has at least a child that has been rotated. Simplify physics before any rotation.";
  this.OBJECT_HAS_ROTATION_SET = "Object has been rotated. Simplify physics before any rotation.";
  this.DISABLED = "disabled";
  this.INVALID_SCRIPT = "Invalid script (@@2): @@1";
  this.SCRIPT_IS_NOT_VALID = "Script is not valid.";
  this.ROYGBIV_SCRIPTING_API_PREFIX = "ROYGBIV_SCRIPTING_API_";
  this.NO_SUCH_FUNCTION = "No such function.";
  this.FUNCTIONS_LIST = "ROYGBIV Scripting API functions";
  this.PERFORMANCES = "Performances in ms";
  this.SCRIPT_EXECUTION_TIME = "Script execution time";
  this.PARTICLE_SYSTEM_UPDATE_TIME = "Particle system update time";
  this.RENDER_TIME = "Render time";
  this.NO_COMMAND_FOUND = "No command found.";
  this.RESOLUTION_SET = "Resolution set.";
  this.IS_NOT_A_NUMBER = "@@1 is not a number.";
  this.BEHAVIOR_UPDATED = "Behavior updated.";
  this.BEHAVIOR_REMOVED = "Behavior removed.";
  this.BEHAVIOR_ALREADY_ADDED = "Behavior already added.";
  this.BEHAVIOR_ADDED = "Behavior added.";
  this.NO_SUCH_BEHAVIOR = "No such behavior in this scene.";
  this.OBJECT_IS_NOT_A_STEERABLE = "Object is not a steerable.";
  this.BEHAVIOR_ASSIGNED_TO_THE_OBJECT = "Behavior assigned to the object.";
  this.BEHAVIOR_ALREADY_ASSIGNED_TO_THE_OBJECT = "Behavior already assigned to the object.";
  this.VELOCITY_TRACKING_STEERING_MODE_DYNAMIC = "Velocity tracking steering mode only works for dynamic objects.";
  this.OBJECT_IS_SET_AS_A_STEERABLE = "Object is set as a steerable.";
  this.OBJECT_WONT_BE_USED_AS_STEERABLE = "Object won't be used as a steerable.";
  this.IS_SET = "@@1 set.";
  this.SWITCHED_TO_TRACK_POSITION = "Steering mode of the object is switched to position tracking.";
  this.POSITION_SET = "Position set.";
  this.CHILD_CONTAINER_IS_ALREADY_ALIGNED = "Child container is already aligned to another parent. Use unalignContainer command first.";
  this.IS_NOT_POWER_OF_TWO = "@@1 is not power of two.";
  this.ATLAS_TEXTURE_SIZE_SET = "Atlas texture size set.";
  this.TEXTURE_RESCALED = "Texture rescaled and saved.";
  this.TEXTURE_SIZE_TOO_SMALL = "Texture size becomes too small after being rescaled.";
  this.TEXTURE_PACK_NAME_MUST_BE_UNIQUE = "Texture pack name must be unique.";
  this.TEXTURE_PACK_RESCALED = "Texture pack rescaled.";
  this.TEXTURE_USED_IN_A_PARTICLE_SYSTEM = "Texture used in a particle system [@@1]. Cannot delete.";
  this.TEXTURE_USED_IN_AN_OBJECT = "Texture used in object [@@1]. Cannot delete.";
  this.TEXTURE_PACK_USED_IN_AN_OBJECT = "Texture pack used in object [@@1]. Cannot delete.";
  this.TEXTURE_PACK_USED_IN_A_PARTICLE_SYSTEM = "Texture pack used in a particle system [@@1]. Cannot delete.";
  this.TEXTURE_PACK_USED_IN_A_SPRITE = "Texture pack used in a sprite [@@1]. Cannot delete.";
  this.TEXTURE_PACK_USED_AS_A_BACKGROUND_TEXTURE = "Texture pack used as a background texture in container [@@1]. Cannot delete.";
  this.TEXTURE_PACK_USED_IN_A_CROSSHAIR = "Texture pack used in a crosshair [@@1]. Cannot delete.";
  this.MATERIAL_USED_IN_AN_OBJECT = "Material used in an object [@@1]. Cannot delete.";
  this.NO_SUCH_IMAGE = "No such image.";
  this.IMAGE_DESTROYED = "Image destroyed.";
  this.NO_MASSES_IN_THE_SCENE = "No masses in the scene.";
  this.IMAGE_USED_IN_TEXTURE = "Image used in texture [@@1]. Cannot delete.";
  this.RESOLUTION_MUST_BE_BETWEEN = "Resolution must be between ]0,1]";
  this.MAX_CHAR_SIZE_MUST_BE_BETWEEN = "maxCharacterSize must be between [1,@@1].";
  this.BLENDING_MODE_SET_TO = "Blending mode set to @@1.";
  this.RAYCASTER_STEP_AMOUNT_SET_TO = "Raycaster step amount set to @@1.";
  this.KEYBOARD_BUFFER_RESET = "Keyboard buffer reset.";
  this.BLENDING_MODE_MUST_BE_ONE_OF = "Blending mode should be one of NO_BLENDING, NORMAL_BLENDING, ADDITIVE_BLENDING, SUBTRACTIVE_BLENDING and MULTIPLY_BLENDING.";
  this.MUST_BE_GREATER_THAN = "@@1 must be greater than @@2.";
  this.MUST_BE_LESS_THAN = "@@1 must be less than @@2.";
  this.ACCEPTED_TEXTURE_SIZE_SET = "Accepted texture size set.";
  this.OCTREE_LIMIT_SET = "World limit set.";
  this.OCTREE_SEGMENTS_SET = "Octree segments set.";
  this.BIN_SIZE_MUST_BE_A_NUMBER = "Bin size must be a number.";
  this.PARAMETERS_MUST_BE_DIVISABLE_BY = "Parameters must be divisable by @@1.";
  this.WORLD_LIMITS_MUST_BE_DIVISABLE_BY_BIN_SIZE = "World limits must be divisable by bin size.";
  this.GRID_SYSTEM_SIZES_MUST_BE_DIVISABLE_BY_BIN_SIZE = "Grid system sizes must be divisable by bin size.";
  this.BIN_SIZE_SET = "Bin size set.";
  this.WORLD_LIMITS = "World limits";
  this.BIN_SIZE = "Bin size";
  this.RAYCASTER_STEP_AMOUNT = "Raycaster step amount";
  this.OBJECT_COPIED = "Object copied.";
  this.MIN = "Min";
  this.MAX = "Max";
  this.THIS_TEXT_IS_ALLOCATED_FOR = "This text is allocated for @@1 characters maximum.";
  this.AREA_CREATED = "Area created.";
  this.AREA_HEIGHT_MUST_BE_DIVISABLE = "Area height must be divisable by grid size.";
  this.HEIGHT_MUST_BE_DIVISIBLE = "Height must be divisable by grid size.";
  this.NO_AREAS_CREATED = "No areas created.";
  this.AREA_CONFIGURATION_WINDOW_IS_ALREADY_VISIBLE = "Area configuration window is already visible.";
  this.AREA_CONFIGURATION_WINDOW_IS_ALREADY_HIDDEN = "Area configuration window is already hidden.";
  this.AREAS_ARE_VISIBLE = "Areas are visible.";
  this.AREAS_ARE_INVISIBLE = "Areas are invisible.";
  this.AREA_INTERSECTS_WITH_OTHER_AREAS = "Area collapses with other areas.";
  this.NO_SUCH_AREA = "No such area.";
  this.REFRESHING_RAYCASTER = "Refreshing raycaster.";
  this.AREA_DESTROYED = "Area destroyed.";
  this.MAX_VIEWPORT_SET = "Max viewport set. Viewport changes can be observed in preview mode.";
  this.ASPECT_FIXED = "Aspect fixed to @@1. Viewport changes can be observed in preview mode.";
  this.ASPECT_UNFIXED = "Aspect unfixed.";
  this.FRAME_DROP_ALREADY = "There is already a frame-drop recording process working.";
  this.FRAME_DROP_STARTED = "Frame-drop recording started.";
  this.DISPLACEMENT_MAP_APPLIED = "Displacement map applied.";
  this.CONFIGURING_AREA = "Configuring area.";
  this.ROYGBIV_SCRIPTING_API_GETOBJECT = "Returns the object or glued object having the name given as the parameter, or undefined if no such object or glued object is found.";
  this.ROYGBIV_SCRIPTING_API_GETPARTICLESYSTEM = "Returns the particle system having the name given as the parameter, or zero if no such particle system is found.";
  this.ROYGBIV_SCRIPTING_API_GETCHILDOBJECT = "Returns a child object having the name given as the second parameter of a glued object given as the first parameter,\nor zero if no such object is found.";
  this.ROYGBIV_SCRIPTING_API_GETRANDOMCOLOR = "Returns the HTML name of a random color.";
  this.ROYGBIV_SCRIPTING_API_HIDE = "Hides an object or a glued object, removes it from the scene. Does nothing if the object is already hidden.\nThe additional keepPhysics parameter can be used in order to hide only the graphical representation of the object but\nkeep its physicsal body. The default value of keepPhysics is false.";
  this.ROYGBIV_SCRIPTING_API_SHOW = "Makes a hidden object or glued object visible. Does nothing if the object is already visible.";
  this.ROYGBIV_SCRIPTING_API_VECTOR = "Creates a new vector from x, y and z coordinates.";
  this.ROYGBIV_SCRIPTING_API_DISTANCE = "Returns the distance between two vectors.";
  this.ROYGBIV_SCRIPTING_API_SUB = "Returns the substraction of two vectors.";
  this.ROYGBIV_SCRIPTING_API_ADD = "Returns the summation of two vectors.";
  this.ROYGBIV_SCRIPTING_API_MOVETOWARDS = "Moves vec1 towards vec2 by given amount and returns the new position of vec1. If amount is 1, vec1 goes all the way towards vec2.";
  this.ROYGBIV_SCRIPTING_API_APPLYFORCE = "Applies a physical force to an object or a glued object from a given point.";
  this.ROYGBIV_SCRIPTING_API_ROTATE = "Rotates an object or a glued object around a given axis by given radians. The parameter axis must be one of ROYGBIV.axes.X,\nROYGBIV.axes.Y or ROYGBIV.axes.Z. Objects are rotated around their own centers, so their positions do not change when rotated\nusing this function. If object has a local rotation mode set, the rotation is performed around it's local axis, it's performed\naround the world axis otherwise.";
  this.ROYGBIV_SCRIPTING_API_ROTATEAROUNDXYZ = "Rotates an object or a glued object around the given (x, y, z). Unlike the rotate function, the positions of the objects\ncan change when rotated using this function. Note that axis must be one of ROYGBIV.axes.X, ROYGBIV.axes.Y or ROYGBIV.axes.Z.";
  this.ROYGBIV_SCRIPTING_API_SETPOSITION = "Puts an object or glued object to the specified (x, y, z) coordinate.";
  this.ROYGBIV_SCRIPTING_API_COLOR = "Creates a new color object from the given HTML color name.";
  this.ROYGBIV_SCRIPTING_API_SETMASS = "Sets the mass property of an object or a glued object. Objects are considered dynamic if and only if their mass is greater than zero.";
  this.ROYGBIV_SCRIPTING_API_TRANSLATE = "Translates an object or glued object on the given axis by the given amount.\nAxis must be one of ROYGBIV.axes.X, ROYGBIV.axes.Y or ROYGBIV.axes.Z.";
  this.ROYGBIV_SCRIPTING_API_GETPOSITION = "Returns the (x, y, z) coordinates of an object, glued object or a particle system.\nIf a specific axis is specified, only the position on the specified axis is returned.\nNote that axis should be one of ROYGBIV.axes.X, ROYGBIV.axes.Y or ROYGBIV.axes.Z.";
  this.ROYGBIV_SCRIPTING_API_OPACITY = "Increases/decreases the opacity of given object.";
  this.ROYGBIV_SCRIPTING_API_GETOPACITY = "Returns the opacity of given object.";
  this.ROYGBIV_SCRIPTING_API_SETCOLLISIONLISTENER = "Sets a collision listener for an object, glued object or a particle system."+
                                                    "Callback function given as the second parameter is\nfired with a CollisionInfo instance when the sourceObject is collided with other objects or glued objects of the scene.\n"+
                                                    "The additional timeOffset parameter can be used for particle systems to pre-calculate future collisions. This can help to\nprevent visual errors of collisions of rather fast particle systems.";
  this.ROYGBIV_SCRIPTING_API_REMOVECOLLISIONLISTENER = "Removes collision listeners of an object, glued object or a particle system.";
  this.ROYGBIV_SCRIPTING_API_SETPARTICLESYSTEMROTATION = "Sets the rotation of a particle system around given axis. Note that axis must be one of ROYGBIV.axes.X, ROYGBIV.axes.Y\nor ROYGBIV.axes.Z.";
  this.ROYGBIV_SCRIPTING_API_SETPARTICLESYSTEMQUATERNION = "Sets the quaternion of given particle system.";
  this.ROYGBIV_SCRIPTING_API_GETMARKEDPOSITION = "Returns (x,y,z) coordinates of a point marked using the mark command.";
  this.ROYGBIV_SCRIPTING_API_SETEXPIRELISTENER = "Sets an expiration listener for a particle system. The parameter callbackFunction is executed when sourceObject is expired.\nThe name of the particle system is passed to the callbackFunction as a parameter.";
  this.ROYGBIV_SCRIPTING_API_REMOVEEXPIRELISTENER = "Removes the expiration listener function of a particle system.";
  this.ROYGBIV_SCRIPTING_API_NORMALIZEVECTOR = "Normalizes the vector given in the parameter. Note that this function modifies directly the parameter and returns nothing.";
  this.ROYGBIV_SCRIPTING_API_COMPUTEQUATERNIONFROMVECTORS = "Returns the quaternion between two vectors.";
  this.ROYGBIV_SCRIPTING_API_MULTIPLYSCALAR = "Multiplies a vector by a scalar.";
  this.ROYGBIV_SCRIPTING_API_GETPARTICLESYSTEMVELOCITYATTIME = "Calcualtes and returns the velocity vector of a particle system at given time. For particles with circular motion, this function returns\nthe angular velocity at given time.";
  this.ROYGBIV_SCRIPTING_API_STOPPARTICLESYSTEM = "Stops the motion of a particle system. This can be useful for smooth after collision effects of particle systems as it lets particles\nto dissapear smoothly. The particle system is killed after stopDuration seconds.";
  this.ROYGBIV_SCRIPTING_API_STARTPARTICLESYSTEM = "Starts a particle system after its creation. Configurations are:\n"+
                                                     "particleSystem: The particle system to start. (mandatory)\n"+
                                                     "startPosition: The initial position vector of the particle system. (optional)\n"+
                                                     "startVelocity: The initial velocity vector of the particle system. (optional)\n"+
                                                     "startAcceleration: The initial acceleration vector of the particle system. (optional)\n"+
                                                     "startQuaternion: The initial quaternion of the particle system. Use ROYGBIV.computeQuaternionFromVectors (optional)\n"+
                                                     "maxCameraDistance: This parameter can be used for particle systems being shot from FPS weapons to visually adjust their scales.\nIf set, the scale of the particle system is set to [distance_to_camera] / maxCameraDistance while the distance to camera is\nless than maxCameraDistance.";
  this.ROYGBIV_SCRIPTING_API_HIDEPARTICLESYSTEM = "Makes a particle system invisible.";
  this.ROYGBIV_SCRIPTING_API_GETCAMERADIRECTION = "Returns the direction vector of the camera.";
  this.ROYGBIV_SCRIPTING_API_GETCAMERAPOSITION = "Returns the position of the camera.";
  this.ROYGBIV_SCRIPTING_API_GETPARTICLESYSTEMPOOL = "Finds a particle system pool by name and returns it.";
  this.ROYGBIV_SCRIPTING_API_GETPARTICLESYSTEMFROMPOOL = "Returns an available particle system from the pool, or false if there is not an available particle system inside the pool.\nThe particle systems become available when hidden or expired.";
  this.ROYGBIV_SCRIPTING_API_SETVECTOR = "Set the x, y, z components of a vector.";
  this.ROYGBIV_SCRIPTING_API_QUATERNION = "Returns a new THREE.Quaternion instance.";
  this.ROYGBIV_SCRIPTING_API_FADEAWAY = "Makes the particles of given particle system smaller on each frame. Greater the coefficient, faster the particles fade away.\nThis can be used for smoke like particle systems to make them dissapear smoothly.";
   this.ROYGBIV_SCRIPTING_API_SELECTCROSSHAIR = "Selects a crosshair. Only the selected crosshair is visible on the screen.";
   this.ROYGBIV_SCRIPTING_API_CHANGECROSSHAIRCOLOR = "Changes the color of the selected crosshair.";
   this.ROYGBIV_SCRIPTING_API_HIDECROSSHAIR = "Destroys the selected crosshair. selectCrosshair function should be used after this function\nin order to put a crosshair on the screen.";
   this.ROYGBIV_SCRIPTING_API_STARTCROSSHAIRROTATION = "Starts rotation effect of the selected crosshair.";
   this.ROYGBIV_SCRIPTING_API_STOPCROSSHAIRROTATION = "Stops rotation effect of the selected crosshair.";
   this.ROYGBIV_SCRIPTING_API_PAUSECROSSHAIRROTATION = "Pauses rotation effect of the selected crosshair. startCrosshairRotation function can be used to continue the rotation effect.";
   this.ROYGBIV_SCRIPTING_API_EXPANDCROSSHAIR = "Expands a crosshair. This can be used while shooting or walking for fps games. The crosshair expands by delta while\nits size is less than targetSize on each frame. This function is designed to be called inside onmousedown or onkeydown like events.";
   this.ROYGBIV_SCRIPTING_API_SHRINKCROSSHAIR = "Shrinks a crosshair. This can be used after calling the expandCrosshair function. The crosshair shrinks by delta while its size is\ngreater than its initial size. This function is designed to be called inside onmouseup or onkeyup like events.";
   this.ROYGBIV_SCRIPTING_API_SETPARTICLESYSTEMPOSITION = "Sets the position of a particle system. This function is designed for magic circle like particle systems which may follow players.\nThis function should not be used for particle systems with collision callbacks or particle systems with defined motions in general.";
   this.ROYGBIV_SCRIPTING_API_STARTMOTIONBLUR = "Starts the motion blur effect of an object.";
   this.ROYGBIV_SCRIPTING_API_STOPMOTIONBLUR = "Stops the motion blur effect of an object. The effect can be restarted using the startMotionBlur command.";
   this.ROYGBIV_SCRIPTING_API_SETOBJECTVELOCITY = "Sets the velocity of an object or a glued object. The object must be a dynamic object (mass > 0) in order to have a velocity.\nIf optional axis parameter is used velocity on only given axis is set. Note that axis must be one of ROYGBIV.axes.X,\nROYGBIV.axes.Y or ROYGBIV.axes.Z.";
   this.ROYGBIV_SCRIPTING_API_SETOBJECTCLICKLISTENER = "Sets a click listener for an object or an object group. The callbackFunction is executed with\nx, y, z coordinates of the clicked point. The callbackFunction is bound to object (this = object inside the function).";
   this.ROYGBIV_SCRIPTING_API_REMOVEOBJECTCLICKLISTENER = "Removes the click listener of an object or an object group.";
   this.ROYGBIV_SCRIPTING_API_SETOBJECTCOLOR = "Modifies the color and alpha value of an object or an object group.";
   this.ROYGBIV_SCRIPTING_API_RESETOBJECTCOLOR = "Resets the color and alpha value of an object or an object group.";
   this.ROYGBIV_SCRIPTING_API_SETSCREENCLICKLISTENER = "Sets a click listener for the screen. The callbackFunction is executed with x, y coordinates when clicked on the screen.";
   this.ROYGBIV_SCRIPTING_API_REMOVESCREENCLICKLISTENER = "Removes the click listener of screen.";
   this.ROYGBIV_SCRIPTING_API_SETSCREENMOUSEDOWNLISTENER = "Sets a mouse down listener for screen. The callbackFunction is executed with x, y coordinates when mouse-downed on the screen.";
   this.ROYGBIV_SCRIPTING_API_REMOVESCREENMOUSEDOWNLISTENER = "Removes the mouse down listener of screen.";
   this.ROYGBIV_SCRIPTING_API_SETSCREENMOUSEUPLISTENER = "Sets mouse up listener for screen. The callbackFunction is executed with x, y coordinates when mouse-upped on the screen.";
   this.ROYGBIV_SCRIPTING_API_REMOVESCREENMOUSEUPLISTENER = "Removes mouse up listener for screen.";
   this.ROYGBIV_SCRIPTING_API_SETSCREENMOUSEMOVELISTENER = "Sets mouse move listener for screen. The callbackFunction is executed with x, y coordinates and dX, dY values when\nmouse moves on the screen.";
   this.ROYGBIV_SCRIPTING_API_REMOVESCREENMOUSEMOVELISTENER = "Removes mouse move listener for screen.";
   this.ROYGBIV_SCRIPTING_API_REQUESTPOINTERLOCK = "Requests pointer lock from window on the next click.";
   this.ROYGBIV_SCRIPTING_API_CONVERTEULERTODEGREES = "Returns the degree equivalent of an Euler angle.";
   this.ROYGBIV_SCRIPTING_API_SETSCREENPOINTERLOCKCHANGELISTENER = "Sets a callback function for Pointer Lock API status changes. The callbackFunction is executed with isPointerLocked parameter.";
   this.ROYGBIV_SCRIPTING_API_REMOVESCREENPOINTERLOCKCHANGELISTENER = "Removes the Pointer Lock change listener for the screen.";
   this.ROYGBIV_SCRIPTING_API_SETPARTICLESYSTEMPOOLCONSUMEDLISTENER = "Sets a listener for particle system pool consumption. The callbackFunction is executed wheren there is no available\nparticle system left inside the pool.";
   this.ROYGBIV_SCRIPTING_API_REMOVEPARTICLESYSTEMPOOLCONSUMEDLISTENER = "Removes the consumption listener of a particle system pool.";
   this.ROYGBIV_SCRIPTING_API_SETPARTICLESYSTEMPOOLAVAILABLELISTENER = "Sets an availability listener for a particle system pool. The callbackFunction is executed when there is at least\none available particle system inside the pool again.";
   this.ROYGBIV_SCRIPTING_API_REMOVEPARTICLESYSTEMPOOLAVAILABLELISTENER = "Removes the availablity listener for a particle system pool.";
   this.ROYGBIV_SCRIPTING_API_ISKEYPRESSED = "Returns whether the given key is pressed or not. See the keyCodeToChar variable for possible key names.";
   this.ROYGBIV_SCRIPTING_API_SETCAMERAPOSITION = "Sets the position of the camera.";
   this.ROYGBIV_SCRIPTING_API_LOOKAT = "Makes the camera look at specific position.";
   this.ROYGBIV_SCRIPTING_API_APPLYAXISANGLE = "Rotates the vector around an axis by given angle.";
   this.ROYGBIV_SCRIPTING_API_TRACKOBJECTPOSITION = "Makes sourceObject keep its relative position to targetObject.";
   this.ROYGBIV_SCRIPTING_API_UNTRACKOBJECTPOSITION = "Stops tracking an objects position for an object.";
   this.ROYGBIV_SCRIPTING_API_CREATEROTATIONPIVOT = "Creates and returns a rotation pivot for an object. This function is not optimized for the runtime. Use this function before\nsetRotationPivot API on initialization. Instead of ROYGBIV.rotate API that works on world axes, this function may be used with\n0 offset parameters to achieve local rotation for objects.";
   this.ROYGBIV_SCRIPTING_API_SETROTATIONPIVOT = "Sets a rotation pivot for an object created with createRotationPivot API.";
   this.ROYGBIV_SCRIPTING_API_UNSETROTATIONPIVOT = "Unsets a rotation pivot point for an object set with setRotationPivot API.";
   this.ROYGBIV_SCRIPTING_API_ROTATECAMERA = "Rotates the camera around its axis by given radians. Note that axis must be one of ROYGBIV.axes.X, ROYGBIV.axes.Y\nor ROYGBIV.axes.Z.";
   this.ROYGBIV_SCRIPTING_API_TRANSLATECAMERA = "Translates the camera along given axis by given amount. Note that axis must be one of ROYGBIV.axes.X, ROYGBIV.axes.Y\nor ROYGBIV.axes.Z.";
   this.ROYGBIV_SCRIPTING_API_REQUESTFULLSCREEN = "Goes to full screen mode. on the next mouse click. Does nothing if the screen is already in full screen mode.";
   this.ROYGBIV_SCRIPTING_API_SETFULLSCREENCHANGECALLBACKFUNCTION = "Sets a callback function for fullscreen change API. The callbackFunction is executed with isFullScreenOn\nboolean parameter when the fullscreen status is changed.";
   this.ROYGBIV_SCRIPTING_API_REMOVEFULLSCREENCHANGECALLBACKFUNCTION = "Removes the fullscreen change listener.";
   this.ROYGBIV_SCRIPTING_API_ISMOUSEDOWN = "Returns true if the mouse is pressed, false otherwise.";
   this.ROYGBIV_SCRIPTING_API_INTERSECTIONTEST = "Finds the first intersected object on a ray. The onComplete callback function is executed with x, y, z and objectName parameters.\nIf there's no intersection, the objectName is set to null. If the web workers not supported, the onComplete is executed immediately."
   this.ROYGBIV_SCRIPTING_API_GETENDPOINT = "Gets an end point of an object. The axis may be one of:\nROYGBIV.endpoints.MINUS_X\nROYGBIV.endpoints.MINUS_Y\nROYGBIV.endpoints.MINUS_Z\nROYGBIV.endpoints.PLUS_X\nROYGBIV.endpoints.PLUS_Y\nROYGBIV.endpoints.PLUS_Z\n\nNote that object groups do not support this function but child objects do. This function may be useful in cases where\nfor example a particle system needs to be started from the tip point of an object.";
   this.ROYGBIV_SCRIPTING_API_ISMOBILE = "Returns if the current client is a mobile client.";
   this.ROYGBIV_SCRIPTING_API_LERP = "Linearly interpolate between vector1 and vector2. The result is vector1 if amount = 0 and vector2 if amount = 1.";
   this.ROYGBIV_SCRIPTING_API_RESETOBJECTVELOCITY = "Resets the velocity and angular velocity of an object.";
   this.ROYGBIV_SCRIPTING_API_SETFPSDROPCALLBACKFUNCTION = "Sets a callback function for FPS drops. The callbackFunction is executed with dropAmount parameter if the FPS is\nless than 60 for given second. The dropAmount is calculated using this formula: (60 - [current_fps])";
   this.ROYGBIV_SCRIPTING_API_REMOVEFPSDROPCALLBACKFUNCTION = "Removes the callback function for FPS drops.";
   this.ROYGBIV_SCRIPTING_API_SETPERFORMANCEDROPCALLBACKFUNCTION = "Sets a callback function for performance drops. The callbackFunction is executed if the FPS is under [minFPS] for [seconds] seconds.\nThe callbackFunction is automatically removed after the execution, so use this function again if needed after\nthe execution of the callbackFunction.";
   this.ROYGBIV_SCRIPTING_API_REMOVEPERFORMANCEDROPCALLBACKFUNCTION = "Removes the callback function for performance drops.";
   this.ROYGBIV_SCRIPTING_API_GETVIEWPORT = "Returns the current viewport object having startX, startY, width and height parameters.\nDo not modify the values of the returned object.";
   this.ROYGBIV_SCRIPTING_API_SETUSERINACTIVITYCALLBACKFUNCTION = "Sets a callback function for user inactivity. The callbackFunction is executed if the user does not move or press the mouse or\npress a key for more than maxTimeInSeconds seconds. The callbackFunction is reset after the execution so use this function again\nto create a new inactivity listener.";
   this.ROYGBIV_SCRIPTING_API_REMOVEUSERINACTIVITYCALLBACKFUNCTION = "Removes the user inactivity callback function.";
   this.ROYGBIV_SCRIPTING_API_PAUSE = "Pauses/unpauses rendering. Note that once the rendering is paused the scripts also pause so in order to unpause the rendering,\nuse callback functions such as ROYGBIV.setScreenClickListener or ROYGBIV.setScreenPointerLockChangeListener.";
   this.ROYGBIV_SCRIPTING_API_SETSCREENKEYDOWNLISTENER = "Sets a keydown listener. The callbackFunction is executed with the pressedChar parameter. See the values of keyCodeToChar\nvariable for possible pressedChar parameters.";
   this.ROYGBIV_SCRIPTING_API_REMOVESCREENKEYDOWNLISTENER = "Removes the keydown listener.";
   this.ROYGBIV_SCRIPTING_API_SETSCREENKEYUPLISTENER = "Sets a keyup listener. The callbackFunction is executed with the uppedChar parameter. See the values of keyCodeToChar\nvariable for possible uppedChar parameters.";
   this.ROYGBIV_SCRIPTING_API_REMOVESCREENKEYUPLISTENER = "Removes the keyup listener.";
   this.ROYGBIV_SCRIPTING_API_GETTEXT = "Returns a text object or 0 if the text does not exist.";
   this.ROYGBIV_SCRIPTING_API_SETTEXT = "Sets a text to a text object.";
   this.ROYGBIV_SCRIPTING_API_SETTEXTCOLOR = "Sets the color of a text. colorName can be a color name like red or an hex string like #afef54.";
   this.ROYGBIV_SCRIPTING_API_SETTEXTALPHA = "Sets the alpha of a text.";
   this.ROYGBIV_SCRIPTING_API_SETTEXTPOSITION = "Sets the position of a text object. If text is 2D only x and y parameters are necessary representing the marginX and marginY.";
   this.ROYGBIV_SCRIPTING_API_SETTEXTBACKGROUND = "Sets the background color/alpha of a text object.";
   this.ROYGBIV_SCRIPTING_API_REMOVETEXTBACKGROUND = "Removes the background of a text object.";
   this.ROYGBIV_SCRIPTING_API_ONTEXTCLICK = "Sets a click listener for a text object. The callbackFunction is executed with textName parameter when the text object is clicked.";
   this.ROYGBIV_SCRIPTING_API_REMOVETEXTCLICKLISTENER = "Removes the click listener of a text object.";
   this.ROYGBIV_SCRIPTING_API_SETTEXTCENTERPOSITION = "Puts the center of the given text object to given x, y, z coordinates.";
   this.ROYGBIV_SCRIPTING_API_HIDETEXT = "Makes the given text object invisible. Does nothing if the text is already invisible.";
   this.ROYGBIV_SCRIPTING_API_SHOWTEXT = "Makes the given text object visible. Does nothing if the text is already visible.";
   this.ROYGBIV_SCRIPTING_API_GETFPS = "Returns the current FPS";
   this.ROYGBIV_SCRIPTING_API_EXECUTEFOREACHOBJECT = "Executes the given function for each object and object group. The func paremter is executed with\nobject and objectName parameters.";
   this.ROYGBIV_SCRIPTING_API_GETRANDOMINTEGER = "Returns a random integer in range [minInclusive, maxInclusive]";
   this.ROYGBIV_SCRIPTING_API_ISANYFINGERTOUCHING = "For mobile devices, returns true if there is any finger touching to the screen.";
   this.ROYGBIV_SCRIPTING_API_GETCURRENTTOUCHCOUNT = "For mobile devices, returns the amount of fingers touching to the screen.";
   this.ROYGBIV_SCRIPTING_API_SETSCREENMOUSEWHEELLISTENER = "Sets a mouse wheel listener. The callbackFunction is executed with deltaX and deltaY parameters when a mousewheel event is triggered.";
   this.ROYGBIV_SCRIPTING_API_REMOVESCREENMOUSEWHEELLISTENER = "Removes the listener for mousewheel events.";
   this.ROYGBIV_SCRIPTING_API_SETSCREENPINCHLISTENER = "For mobile devices, sets a pinch zoom gesture listener. The callbackFunction is executed with delta parameter\nthat represents the variation of the distance between two fingers.";
   this.ROYGBIV_SCRIPTING_API_REMOVESCREENPINCHLISTENER = "Removes the listener for pinch gesture.";
   this.ROYGBIV_SCRIPTING_API_SETOBJECTMOUSEOVERLISTENER = "Sets a mouseover listener for an object or an object group. The callbackFunction is executed with x, y, z coordinates of mouse.\nThe callbackFunction is bound to object (this = object inside the function).";
   this.ROYGBIV_SCRIPTING_API_REMOVEOBJECTMOUSEOVERLISTENER = "Removes the mouseover listener of an object or an object group.";
   this.ROYGBIV_SCRIPTING_API_SETOBJECTMOUSEOUTLISTENER = "Sets a mouseout listener for an object or an object group. The callbackFunction is bound to object (this = object inside the function).";
   this.ROYGBIV_SCRIPTING_API_REMOVEOBJECTMOUSEOUTLISTENER = "Removes the mouseout listener of an object or an object group.";
   this.ROYGBIV_SCRIPTING_API_ONTEXTMOUSEOVER = "Sets a mouseover listener for a text. The callbackFunction is bound to text (this = text inside the function).";
   this.ROYGBIV_SCRIPTING_API_REMOVETEXTMOUSEOVERLISTENER = "Removes the mouseover listener of a text.";
   this.ROYGBIV_SCRIPTING_API_ONTEXTMOUSEOUT = "Sets a mouseout listener for a text. The callbackFunction is bound to text (this = text inside the function).";
   this.ROYGBIV_SCRIPTING_API_REMOVETEXTMOUSEOUTLISTENER = "Removes the mouseout listener of a text.";
   this.ROYGBIV_SCRIPTING_API_ONOBJECTPOSITIONTHRESHOLDEXCEEDED = "Sets a listener for an object detecting the position threshold passage for given axis. If controlMode = 1 the callbackFunction\nis executed when object.position[axis] > threshold, if controlMode = 2 the callbackFunction is executed when\nobject.position[axis] < threshold. The callbackFunction is bound to object (this = object inside the function)."+
                                                                  "This API\nmay be used to restart position of objects that went out of bounds of the scene by falling down etc.";
   this.ROYGBIV_SCRIPTING_API_REMOVEOBJECTPOSITIONTHRESHOLDEXCEEDEDLISTENER = "Removes the position threshold passage listener for an object. Does nothing if the object does not have such listener.";
   this.ROYGBIV_SCRIPTING_API_CREATEFREECONTROL = "Creates a new FreeControl implementation where the camera can freely move inside the scene for both desktop and mobile devices.\nThe controls are:\n" +
                                                  "WSAD or ZQSD (French keyboard): Translate on plane XZ\n" +
                                                  "E - Space: Translate on axis Y\n" +
                                                  "Arrow keys or touch (mobile): Look around\n" +
                                                  "Finger pinch (mobile) - Mouse wheel (desktop): Translate on axis Z\n"+
                                                  "The configurations are:\n"+
                                                  "rotationYDelta (optional): Camera rotation amount for left-right keys. Default is 0.07.\n"+
                                                  "rotationXDelta (optional): Camera rotation amount for up-down keys. Default is 0.07.\n"+
                                                  "translateZAmount (optional): Translation amount on Z axis for WS or ZS keys or finger pinch events. Default is 3.\n"+
                                                  "translateXAmount (optional): Translation amount on X axis for DA or DQ keys. Default is 3.\n"+
                                                  "translateYAmount (optional): Translation amount on Y axis for E-Space keys. Default is 3.\n"+
                                                  "mouseWheelSpeed (optional): Translation speed for mousewheel zoom in/out. Default is 1.\n"+
                                                  "swipeSpeed (optional): Rotation speed for look with touch events on mobile. Default is 0.002.\n"+
                                                  "mouseDragSpeed (optional): Rotation speed for mouse drag events on desktop devices. Default is 15.\n"+
                                                  "requestFullScreen (optional): If true, fullscreen mode is requested automatically. Default is false.";
  this.ROYGBIV_SCRIPTING_API_CREATECUSTOMCONTROL = "Creates a CustomControl implementation. This API may be used to create custom controls by filling the related event handlers.\nParameters are:\n"+
                                                 "onClick (optional): Function to be executed with the click event when the user clicks. Default value is noop.\n"+
                                                 "onTap (optional): Function to be executed with the touch event when the user taps (mobile). Default value is noop.\n"+
                                                 "onSwipe (optional): Function to be executed with x, y, diffX and diffY parameters when the user moves their finger on the screen (mobile).\nDefault value is noop.\n"+
                                                 "onPinch (optional): Function to be executed with diff parameter when the user performs a pinch zoom (mobile). Default value is noop.\n"+
                                                 "onMouseWheel (optional): Function to be executed with the mouse wheel event when the user performs a mouse wheel. Default value is noop.\n"+
                                                 "onMouseMove (optional): Function to be executed with the mouse move event when the user performs a mouse move. Default value is noop.\n"+
                                                 "onMouseDown (optional): Function to be executed with the mouse down event when the user performs a mouse down. Default vaue is noop.\n"+
                                                 "onMouseUp (optional): Function to be executed with the mouse up event when the user performs a mouse up. Default value is noop.\n"+
                                                 "onTouchStart (optional): Function to be executed with the TouchEvent when the user performs a touch start. Default value is noop.\n"+
                                                 "onTouchMove (optional): Function to be executed with the TouchEvent when the user performs a touch move. Default value is noop.\n"+
                                                 "onTouchEnd (optional): Function to be executed with the TouchEvent when the user performs a touch end. Default value is noop.\n"+
                                                 "onResize (optional): Function to be executed when the screen is resized. Default value is noop.\n"+
                                                 "onFullScreenChange (optional): Function to be executed with the isFullScreen parameter when the fullscreen status of the screen is\nchanged. Default value is noop.\n"+
                                                 "onDrag (optional): Function to be executed with x, y, movementX, movementY parameters when the user performs a moue drag operation.\nDefault value is noop.\n"+
                                                 "onUpdate (optional): Function to be executed on each frame. Default value is noop.";
 this.ROYGBIV_SCRIPTING_API_SETACTIVECONTROL = "Sets the active control.";
 this.ROYGBIV_SCRIPTING_API_CREATEFPSCONTROL = "Creates a new FPSControls object to be used in First Person Shooter games for both desktop and mobile devices. FPSControls automatically\nhandles the PointerLock as well. The controls are:\n"+
                                              "For desktop:\n"+
                                              "WSAD/ZQSD (French keyboard) / Arrow Keys: Move\n"+
                                              "Mouse: Look\n"+
                                              "Click: Shoot\n"+
                                              "Space: Jump\n"+
                                              "For mobile:\n"+
                                              "Left side of the screen: Move\n"+
                                              "Right side of the screen: Look around\n"+
                                              "Tap on the right side of the screen: Jump\n"+
                                              "For mobile devices controls are automatically paused for portrait orientation.\n"+
                                              "Configurations are:\n"+
                                              "playerBodyObject (mandatory): A dummy sphere type object to physically represent the player. The camera is placed on the\ncenter of the playerBodyObject. The playerBodyObject is graphically hidden when the FPSControls object is activated,\nshown again when deactivated. The playerBodyObject must be a dynamic object (mass > 0) and must be marked as changeable in order\nto be used by FPSControls class.\n"+
                                              "initialPosition (mandatory): The initial position of playerBodyObject.\n"+
                                              "mouseSpeed (optional): The speed of mouse based camera look-around event. Default value is 0.002.\n"+
                                              "touchLookSpeed (optional): The speed of touch based camera look*around event. Default value is 0.01.\n"+
                                              "speed (optional): The speed of motion. Default value is 200.\n"+
                                              "jumpSpeed (optional): The jump speed. Default value is 500.\n"+
                                              "touchJoystickThreshold (optional): For the left hand move controls on mobile devices, this parameter is used in order to filter out\nnegligible TouchEvents on finger move, thus preventing flickering moves. The TouchEvents are filtered if the length between the previous\nand the current (pageX, pageY) is less than or equals to touchJoystickThreshold. Default value is 1.5.\n"+
                                              "crosshairName (optional): The name of the Crosshair.\n"+
                                              "crosshairExpandSize (optional): The target size of the crosshair in order to be used for expand animation when the player is moving\nor shooting. Default value is 9.\n"+
                                              "crosshairAnimationDelta (optional): The delta value of the crosshair expand animation. Default value is 0.2.\n"+
                                              "hasDoubleJump (optional): If true, the user may double jump by pressing Space or tapping twice. Default value is true.\n"+
                                              "doubleJumpTimeThresholdInMs (optional): This parameter define the max time in milliseconds between two Space key hits or taps in order\nto perform a double jump. Default value is 500.\n"+
                                              "weaponObject1 (optional): The first weapon object. This might be any object or object group marked as FPS Weapon.\n"+
                                              "weaponObject2 (optional): The second weapon object. This might be any object or object group marked as FPS Weapon.\n"+
                                              "hasIdleGunAnimation (optional): If true weapon objects are animated in order to give the FPS controls a realistic feeling. Default value\nis true.\n"+
                                              "idleGunAnimationSpeed (optional): The speed of the idle gun animation. Default value is 0.05.\n"+
                                              "weaponRotationRandomnessOn (optional): If true the weapons rotate a bit more than the camera in order to give the FPS view more\nrealistic view. Default value is true.\n"+
                                              "onLook (optional): A callback function executed each frame with x, y, z and objName parameters representing the intersected object\nfrom the FPS camera. If there is no intersected object the objName is set to null. Default value is noop.\n"+
                                              "onShoot (optional): A callback function executed with x, y, z and objName parameters representing the intersected object from the FPS\ncamera while the mouse is down for Desktop devices. For mobile devices due to lack of mouse device this function is executed when the\ncamera is looking at one of the shootable objects defined with the shootableObjects parameter in order to help implementing the\nauto-shoot functionality. Default value is noop.\n"+
                                              "onStoppedShooting (optional): A callback function executed without any parameter when the mouse is not down for the first time\nafter it was down.\n"+
                                              "shootableObjects (optional): An array of objects representing the objects that can be shot. This parameter is used inside the onShoot\nevent for mobile devices in order to decide if the object being looked at should trigger the onShoot function or not. Default value\nis an empty array.\n"+
                                              "onPause (optional): A callback function to be executed when the FPS controls are paused on mobile devices due to switching to Portrait\norientation. Default value is noop.\n"+
                                              "onResume (optional): A callback function to be executed on mobile devices when the FPS controls are resumed after switching back to the\nLandscape orientation. Default value is noop.\n"+
                                              "requestFullScreen (optional): If true the FullScreen mode is requested if the screen is not on full screen. FPS Controls API\nalso automatically re-requests the FullScreen mode every time after the user cancels the FullScreen. Default value is true.";

  this.ROYGBIV_SCRIPTING_API_SETSCREENDRAGLISTENER = "Sets a mouse drag listener for the screen. The callbackFunction is executed with x, y, movementX and movementY parameters.";
  this.ROYGBIV_SCRIPTING_API_REMOVESCREENDRAGLISTENER = "Removes the screen drag listener.";
  this.ROYGBIV_SCRIPTING_API_CREATEORBITCONTROL = "Creates a new OrbitControl object. Using the OrbitControl, camera can orbit around a specified point by looking at it on each frame.\nCamera can move freely around the surface of an imaginary sphere. Controls are:\n"+
                                                  "For desktop:\n"+
                                                  "Mouse wheel/Mouse drag: Rotate\n"+
                                                  "Right/Left/D/A/Q: Rotate\n"+
                                                  "Up/Down/W/S/Z: Zoom in/out\n"+
                                                  "Space: Zoom in/out\n"+
                                                  "For mobile:\n"+
                                                  "Finger pinch zoom: Zoom in/out\n"+
                                                  "Finger touch: Rotate\n"+
                                                  "Configurations are:\n"+
                                                  "lookPosition (optional): A vector defining the look position and the center of the imaginary sphere. Default value is (0, 0, 0).\n"+
                                                  "maxRadius (optional): The maximum radius of the imaginary sphere that the camera can zoom out to. Default value is 150.\n"+
                                                  "minRadius (optional): The minimum radius of the imaginary sphere that the camera can zoom in to. Default value is 50.\n"+
                                                  "zoomDelta (optional): The difference of radius when the user performs a zoom in/out. Default value is 1.\n"+
                                                  "mouseWheelRotationSpeed (optional): The speed of mouse wheel rotation. Default value is 3.\n"+
                                                  "mouseDragRotationSpeed (optional): The speed of mouse drag rotation. Default value is 20.\n"+
                                                  "fingerSwipeRotationSpeed (optional): The speed of finger touch rotation for mobile devices. Default value is 20.\n"+
                                                  "keyboardRotationSpeed (optional): The speed of rotation using keyboard events. Default value is 10.\n"+
                                                  "requestFullScreen (optional): If true the FullScreen mode is requested if the screen is not on full screen. Orbit Controls API\nalso automatically re-requests the FullScreen mode every time after the user cancels the FullScreen. Default value is false.";
  this.ROYGBIV_SCRIPTING_API_ISORIENTATIONLANDSCAPE = "For mobile devices returns if the orientation is landscape for mobile devices. Returns false for desktop devices";
  this.ROYGBIV_SCRIPTING_API_SETSCREENORIENTATIONCHANGELISTENER = "Sets a listener for orientation change events. For mobile devices, the callbackFunction is executed with isLandscape parameter\nwhen the orientation is changed.";
  this.ROYGBIV_SCRIPTING_API_REMOVESCREENORIENTATIONCHANGELISTENER = "Removes the listener for orientation change events.";
  this.ROYGBIV_SCRIPTING_API_EXECUTEFOREACHPARTICLESYSTEM = "Runs the provided function for each particle system of given particle system pool. The callbackFunction is executed with\nparticleSystem and particleSystemName parameters.";
  this.ROYGBIV_SCRIPTING_API_STARTSCRIPT = "Starts a script. To get scripts use this format as scriptName:\n"+
                                           "parentdir1_parentdir2_....._parentdirX_scriptFileName\n"+
                                           "For example in order to get a script under the scripts/ root folder example.js, the scriptName parameter should be example. However,\nto get a script under scripts/testFolder/test.js, the scriptName parameter should be testFolder_test.";
  this.ROYGBIV_SCRIPTING_API_STOPSCRIPT = "Stops a script. The scriptName parameter is explained with startScript API.";
  this.ROYGBIV_SCRIPTING_API_STARTANIMATION = "Starts an animation of given object, object group, text or sprite.";
  this.ROYGBIV_SCRIPTING_API_STOPANIMATION = "Stops an animation of given object, object group or text.";
  this.ROYGBIV_SCRIPTING_API_ONANIMATIONFINISHED = "Sets a finish listener for an animation of given object, object group or text. For repeating animations the callbackFunction is\nexecuted before each repeat. For rewinding animations the callbackFunction is executed when the rewind is finished.";
  this.ROYGBIV_SCRIPTING_API_REMOVEANIMATIONFINISHLISTENER = "Removes the finish listener for an animation of given object, object group or text.";
  this.ROYGBIV_SCRIPTING_API_SHOWMUZZLEFLASH = "Shows a muzzle flash. This function may be called each time a FPS weapon is shooting. The optional animationTimeInMS\nparameter can be used to start the muzzle flash with a scale animation. This can be useful for flame-like muzzle flashes.";
  this.ROYGBIV_SCRIPTING_API_EXECUTEDELAYED = "Runs a function after delayInMS milliseconds. If the repeat parameter is set to true runs the function in every delayInMS milliseconds.\nThis function returns a delayedExecutionID. This ID may provided to stopDelayedExecution API\nin order to stop a function to get executed.";
  this.ROYGBIV_SCRIPTING_API_STOPDELAYEDEXECUTION = "Stops a function to get executed with executeDelayed API. The delayedExecutionID parameter should be the return value of\nexecuteDelayed API. This API returns true if a function is found associated with the provided delayedExecutionID parameter,\nreturns false otherwise.";
  this.ROYGBIV_SCRIPTING_API_CHANGESCENE = "Changes the active scene. The readyCallback function is executed when the new scene is ready.";
  this.ROYGBIV_SCRIPTING_API_GETACTIVESCENENAME = "Returns the active scene name.";
  this.ROYGBIV_SCRIPTING_API_FREEZEANIMATIONONFINISH = "Makes an animation freeze on finish. This can be used for certain weapon animations where the weapon starts shooting\nafter going to a certain position/rotation. Use unfreezeAnimation API to undo this. Note that this function should be\nused after starting an animation.";
  this.ROYGBIV_SCRIPTING_API_UNFREEZEANIMATION = "Unfreezes an animation started with freezeOnFinish parameter set to true.";
  this.ROYGBIV_SCRIPTING_API_HIDEMUZZLEFLASH = "Hides a muzzle flash. This function may be called inside onStoppedShooting callback of a FPS control. The optional\nanimationTimeInMS parameter can be used to hide the muzzle flash with a scale animation. This can be useful for\nflame-like muzzle flashes.";
  this.ROYGBIV_SCRIPTING_API_GETANIMATIONSTATE = "Returns the animation state. The animation state can be these global enums:\n"+
                                                 "ANIMATION_STATE_NOT_RUNNING (0)\n"+
                                                 "ANIMATION_STATE_RUNNING (1)\n"+
                                                 "ANIMATION_STATE_FROZEN (2)\n"+
                                                 "ANIMATION_STATE_REWINDING (3)";
  this.ROYGBIV_SCRIPTING_API_CANCELANIMATIONREWIND = "Sets the state of an animation to ANIMATION_STATE_RUNNING for animations that are in ANIMATION_STATE_REWINDING state.";
  this.ROYGBIV_SCRIPTING_API_REWINDANIMATION = "Sets the state of an animation to ANIMATION_STATE_REWINDING for animations that are in ANIMATION_STATE_RUNNING state.\nFor animations in ANIMATION_STATE_FROZEN state, use unfreezeAnimation API instead of this.";
  this.ROYGBIV_SCRIPTING_API_GETLIGHTNING = "Returns a lightning object or 0 if lightning does not exist.";
  this.ROYGBIV_SCRIPTING_API_STARTLIGHTNING = "Starts a lightning. Does nothing if the lightning is already started.";
  this.ROYGBIV_SCRIPTING_API_SETLIGHTNINGSTARTPOINT = "Sets the start point of a lightning.";
  this.ROYGBIV_SCRIPTING_API_SETLIGHTNINGENDPOINT = "Sets the end point of a lightning.";
  this.ROYGBIV_SCRIPTING_API_STOPLIGHTNING = "Stops a lightning. Does nothing if the lightning is already stopped.";
  this.ROYGBIV_SCRIPTING_API_ONAREAENTER = "Executes the callbackFunction with exitedAreaName parameter when the camera enters into given area.\nThe exitedAreaName is the name of the previous area that the camera was in.";
  this.ROYGBIV_SCRIPTING_API_ONAREAEXIT = "Executes the callbackFunction with enteredAreaName parameter when the camera exits from given area.\nThe enteredAreaName is the name of the area that the camera entered into.";
  this.ROYGBIV_SCRIPTING_API_REMOVEAREAENTERLISTENER = "Removes the area enter listener for given area name.";
  this.ROYGBIV_SCRIPTING_API_REMOVEAREAEXITLISTENER = "Removes the area exit listener for given area name.";
  this.ROYGBIV_SCRIPTING_API_GETSPRITE = "Returns a sprite object or 0 if sprite does not exist.";
  this.ROYGBIV_SCRIPTING_API_ONSPRITECLICK = "Sets a sprite click listener. The callbackFunction is executed when the sprite is clicked.";
  this.ROYGBIV_SCRIPTING_API_REMOVESPRITECLICKLISTENER = "Removes the click listener of a sprite object.";
  this.ROYGBIV_SCRIPTING_API_ONSPRITEMOUSEOVER = "Sets a mouse over listener for a sprite.";
  this.ROYGBIV_SCRIPTING_API_REMOVESPRITEMOUSEOVERLISTENER = "Removes the mouseover listener of a sprite.";
  this.ROYGBIV_SCRIPTING_API_ONSPRITEMOUSEOUT = "Sets a mouseout listener for a sprite.";
  this.ROYGBIV_SCRIPTING_API_REMOVESPRITEMOUSEOUTLISTENER = "Removes the mouseout listener of a sprite.";
  this.ROYGBIV_SCRIPTING_API_ONSPRITEDRAGSTART = "Sets a drag start listener for a sprite. The callbackFunction is executed with diffX and diffY\nparameters when a drag is initiated on a draggable sprite.";
  this.ROYGBIV_SCRIPTING_API_ONSPRITEDRAGSTOP = "Sets a drag stop listener for a sprite. The callbackFunction is executed when a user stops dragging a sprite (mouseup/touchend).";
  this.ROYGBIV_SCRIPTING_API_ONSPRITEDRAGGING = "Sets a dragging listener for a sprite. The callbackFunction is executed each time a sprite is relocated while being dragged.";
  this.ROYGBIV_SCRIPTING_API_REMOVESPRITEDRAGSTARTLISTENER = "Removes the drag start listener of a sprite.";
  this.ROYGBIV_SCRIPTING_API_REMOVESPRITEDRAGSTOPLISTENER = "Removes the drag stop listener of a sprite.";
  this.ROYGBIV_SCRIPTING_API_REMOVESPRITEDRAGGINGLISTENER = "Removes the dragging listener of a sprite.";
  this.ROYGBIV_SCRIPTING_API_ARESPRITESINTERSECTED = "Returns if two sprites are intersected.";
  this.ROYGBIV_SCRIPTING_API_SETSPRITECOLOR = "Sets the color of a sprite.";
  this.ROYGBIV_SCRIPTING_API_SETSPRITEALPHA = "Sets the alpha of a sprite.";
  this.ROYGBIV_SCRIPTING_API_HIDESPRITE = "Hides a sprite. Does nothing if the sprite is already hidden.";
  this.ROYGBIV_SCRIPTING_API_SHOWSPRITE = "Shows a sprite. Does nothing if the sprite is already visible.";
  this.ROYGBIV_SCRIPTING_API_SETSPRITEMARGIN = "Sets the margin of a sprite.";
  this.ROYGBIV_SCRIPTING_API_SETSPRITEROTATIONANGLE = "Sets the rotation of a sprite. Angle is expected to be between [0, 360].";
  this.ROYGBIV_SCRIPTING_API_ENABLESPRITEDRAGGING = "Enables dragging for draggable sprites. Dragging is initially enabled for draggable sprites.";
  this.ROYGBIV_SCRIPTING_API_DISABLESPRITEDRAGGING = "Disables dragging for draggable sprites. Dragging is initially enabled for draggable sprites.";
  this.ROYGBIV_SCRIPTING_API_DEGREETORADIAN = "Converts degrees to radians.";
  this.ROYGBIV_SCRIPTING_API_GETCONTAINER = "Returns a container or 0 if container does not exist.";
  this.ROYGBIV_SCRIPTING_API_ONCONTAINERCLICK = "Sets a click listener for a container. The callbackFunction is executed when the container is clicked.";
  this.ROYGBIV_SCRIPTING_API_REMOVECONTAINERCLICKLISTENER = "Removes the click listener of a container.";
  this.ROYGBIV_SCRIPTING_API_ONCONTAINERMOUSEOVER = "Sets a mouse over listener for a container. The callbackFunction is executed when the mouse is moved over a container.";
  this.ROYGBIV_SCRIPTING_API_REMOVECONTAINERMOUSEOVERLISTENER = "Removes the mouse over listener for a container.";
  this.ROYGBIV_SCRIPTING_API_ONCONTAINERMOUSEOUT = "Sets a mouse out listener for a container. The callbackFunction is executed when the mouse is moved out from a container.";
  this.ROYGBIV_SCRIPTING_API_REMOVECONTAINERMOUSEOUTLISTENER = "Removes the mouse out listener for a container.";
  this.ROYGBIV_SCRIPTING_API_HIDECONTAINERBORDER = "Hides the border of a container.";
  this.ROYGBIV_SCRIPTING_API_SHOWCONTAINERBORDER = "Shows the border of a container.";
  this.ROYGBIV_SCRIPTING_API_SETCONTAINERBORDERCOLOR = "Sets the border color of a container.";
  this.ROYGBIV_SCRIPTING_API_SETCONTAINERBACKGROUNDCOLOR = "Sets the background color of a container.";
  this.ROYGBIV_SCRIPTING_API_SETCONTAINERBACKGROUNDALPHA = "Sets the alpha value of the background of a container.";
  this.ROYGBIV_SCRIPTING_API_HIDECONTAINERBACKGROUND = "Hides the background of a container.";
  this.ROYGBIV_SCRIPTING_API_SHOWCONTAINERBACKGROUND = "Shows the background of a container.";
  this.ROYGBIV_SCRIPTING_API_GETVIRTUALKEYBOARD = "Returns a virtual keyboard or 0 if virtual keyboard does not exist.";
  this.ROYGBIV_SCRIPTING_API_ACTIVATEVIRTUALKEYBOARD = "Activates a virtual keyboard.";
  this.ROYGBIV_SCRIPTING_API_ONVIRTUALKEYBOARDTEXTCHANGE = "Sets a text change listener to a virtual keyboard. The callbackFunction is executed with newText parameter\neverytime a text of a virtual keyboard is changed.";
  this.ROYGBIV_SCRIPTING_API_REMOVEVIRTUALKEYBOARDTEXTCHANGELISTENER = "Removes the text change listener from a virtual keyboard.";
  this.ROYGBIV_SCRIPTING_API_ONVIRTUALKEYBOARDFLUSH = "Sets a flush listener to a virtual keyboard. The callbackFunction is executed with flushedText parameter\nwhen the user presses on the OK button of a virtual keyboard.";
  this.ROYGBIV_SCRIPTING_API_REMOVEVIRTUALKEYBOARDFLUSHLISTENER = "Removes the flush listener from a virtual keyboard.";
  this.ROYGBIV_SCRIPTING_API_HIDEVIRTUALKEYBOARD = "Hides a virtual keyboard. Does nothing if the virtual keyboard if already hidden.";
  this.ROYGBIV_SCRIPTING_API_SHOWVIRTUALKEYBOARD = "Shows a virtual keyboard. Does nothing if the virtual keyboard is already visible.";
  this.ROYGBIV_SCRIPTING_API_DEACTIVATEVIRTUALKEYBOARD = "Deactivates a virtual keyboard. Does nothing if the virtual keyboard is already not active.";
  this.ROYGBIV_SCRIPTING_API_ACTIVATETEXTINPUTMODE = "Activates the input mode for a 2D text. Does nothing if the text is already in input mode.\nThe optional cursorSizePercent parameter can be used to adjust the cursor size\n(cursorSize = charSize * cursorSizePercent / 100)";
  this.ROYGBIV_SCRIPTING_API_DEACTIVATETEXTINPUTMODE = "Deactivates the input mode for a 2D text. Does nothing if the text is already deactivated from input mode.";
  this.ROYGBIV_SCRIPTING_API_MAPTEXTURETOSPRITE = "Maps a texture pack to given sprite. The texturePackOrName parameter can be the name of a tetxure pack\nor the texture pack itself if loaded with loadDynamicTextures API.";
  this.ROYGBIV_SCRIPTING_API_SETLOCATIONHASH = "Sets a hash to window.location. This can be used to track changes when the user presses on back button.";
  this.ROYGBIV_SCRIPTING_API_ONLOCATIONHASHCHANGE = "Sets a location hash change listener. The callbackFunction is executed with the newHash parameter when the location hash changes.";
  this.ROYGBIV_SCRIPTING_API_REMOVELOCATIONHASHCHANGELISTENER = "Removes the location hash change listener.";
  this.ROYGBIV_SCRIPTING_API_STOREDATA = "Stores data using localStorage API.";
  this.ROYGBIV_SCRIPTING_API_GETSTOREDDATA = "Gets stored data using localStorage API.";
  this.ROYGBIV_SCRIPTING_API_REMOVESTOREDDATA = "Removes stored data using localStorage API.";
  this.ROYGBIV_SCRIPTING_API_ISDEFINED = "Checks if given element is defined.";
  this.ROYGBIV_SCRIPTING_API_CANCELSPRITEDRAG = "Cancels sprite dragging if there is an active sprite dragging.";
  this.ROYGBIV_SCRIPTING_API_GETSPRITEMARGINX = "Returns the marginX value of given sprite.";
  this.ROYGBIV_SCRIPTING_API_GETSPRITEMARGINY = "Returns the marginY value of given sprite.";
  this.ROYGBIV_SCRIPTING_API_LOADDYNAMICTEXTURES = "Loads given textures inside provided dynamic texture folder. onLoadedCallback is executed with results parameter\nwhen the loading process is finished. This results parameter holds either a texture pack object as element\nif the texture could be loaded, or false if not. The order of elements of results parameter and textureNamesArray\nare the same." +
                                                   " ROYGBIV engine automatically takes care of caching, so a texture is not loaded twice from the same path.";
  this.ROYGBIV_SCRIPTING_API_CONNECTTOSERVER = "Connects to a game server, the URL of which is set by setWSServerURL CLI command. The server and the client interacts through\nRhubarb protocol definition files, the path of which is set by setProtocolDefinition CLI command. onReady callback parameter is\nexecuted when the connection is established. onError is executed with errorReason parameter in case there is an error\nestablishing the connection.";
  this.ROYGBIV_SCRIPTING_API_CLEARSERVERCONNECTION = "Disconnects from server and clears Rhubarb context. Does nothing if not connected to server.";
  this.ROYGBIV_SCRIPTING_API_ONDISCONNECTEDFROMSERVER = "Sets a listener for server connection status. The callbackFunction is executed when the connection between\nthe server and the client is lost. If client needs to try reconnecting, ROYGBIV.clearServerConnection API\nneeds to be used before ROYGBIV.connectFromServer.";
  this.ROYGBIV_SCRIPTING_API_SENDTOSERVER = "Sends a message from the server. protocolName is the protocol name defined in protocol definition file.\nvaluesByParameterName is an object containing values to be send by protocol parameter names.\nRead https://github.com/oguzeroglu/Rhubarb/wiki/API-reference#send for more info.";
  this.ROYGBIV_SCRIPTING_API_ONRECEIVEDFROMSERVER = "Listens to server for given protocol and executes callbackFunction when a message received. The callbackFunction is executed\nwith getter parameter. getter is a function which expects a protocol parameter name as input and returns received value\nfor that parameter. Read https://github.com/oguzeroglu/Rhubarb/wiki/API-reference#onReceived for more info.";
  this.ROYGBIV_SCRIPTING_API_ONLATENCYUPDATED = "Listens for latency between the server and the client. The callbackFunction is executed with newLatency (in ms) parameter when the latency is updated.";
  this.ROYGBIV_SCRIPTING_API_APPLYCUSTOMVELOCITY = "Applies velocity to FPS controls for given milliseconds. This can be useful for Valve Ricochet kind of games where\nthe player is manually accelerated with jump pads.";
  this.ROYGBIV_SCRIPTING_API_MAPAREAPOSITIONTOAREA = "Converts a 3D vector within source area into another vector in target area maintanining the ratio.";
  this.ROYGBIV_SCRIPTING_API_CREATEVECTORPOOL = "Returns a vector pool to store reusable vectors. Use getFromVectorPool API to get the vector object.";
  this.ROYGBIV_SCRIPTING_API_GETFROMVECTORPOOL = "Returns a vector from a vector pool create with createVectorPool API.";
  this.ROYGBIV_SCRIPTING_API_GETDYNAMICLIGHT = "Returns a dynamic light or 0 if dynamic light does not exist.";
  this.ROYGBIV_SCRIPTING_API_UPDATELIGHTSTRENGTH = "Updates the strength of a dynamic light.";
  this.ROYGBIV_SCRIPTING_API_UPDATELIGHTCOLOR = "Updates the color of a dynamic light.";
  this.ROYGBIV_SCRIPTING_API_UPDATELIGHTDIRECTION = "Updates the direction of a dynamic light.";
  this.ROYGBIV_SCRIPTING_API_UPDATELIGHTPOSITION = "Updates the position of a dynamic light.";
  this.ROYGBIV_SCRIPTING_API_ATTACHPOINTLIGHTTOOBJECT = "Places a point light into the position of given object each frame.";
  this.ROYGBIV_SCRIPTING_API_SETSTEERINGBEHAVIOR = "Sets the steering behavior of given object.";
  this.ROYGBIV_SCRIPTING_API_STOPSTEERABLE = "Stops a steerable.";
  this.ROYGBIV_SCRIPTING_API_SETSTEERABLETARGETPOSITION = "Sets a target position of a steerable. Target position is consumed by these steering behaviors:\n" +
                                                          "    * Seek\n" +
                                                          "    * Flee\n" +
                                                          "    * Arrive";
  this.ROYGBIV_SCRIPTING_API_UNSETSTEERABLETARGETPOSITION = "Unsets a target position of a steerable set via setSteerableTargetPosition API.";
  this.ROYGBIV_SCRIPTING_API_SETSTEERABLELOOKTARGET = "Makes a steerable gradually look at given target position.";
  this.ROYGBIV_SCRIPTING_API_GETASTAR = "Returns an AStar object or 0 if AStar does not exist.";
  this.ROYGBIV_SCRIPTING_API_FINDSHORTESTPATH = "Calculates the shortest path between given points. This API returns nothing as it automatically pipes\nthe resulting path to the PathFollowingBehavior, if the behavior is constructed with given AStar object.\nSo use this API together with the PathFollowingBehavior.\nIf there's no nearby graph vertex of given vectors, this API does not calculate any path. In that case,\nincreasing the world bin size might help.";
  this.ROYGBIV_SCRIPTING_API_HIDEFROM = "Makes a steerable represented as hidingObject hide from another steerable represented as targetObject.\nThis API should be used with HideBehavior.";
  this.ROYGBIV_SCRIPTING_API_STOPHIDING = "Makes a steerable stop hiding from other entities. It makes sense to use this API with HideBehavior,\nafter using hideFrom API.";
  this.ROYGBIV_SCRIPTING_API_PURSUE = "Makes a steerable represented by pursuingObject chase another steerable represented by targetObject.\nThis API should be used with PursueBehavior.";
  this.ROYGBIV_SCRIPTING_API_EVADE = "Makes a steerable represented by evadingObject evade another steerable represented by targetObject.\nThis API should be used with EvadeBehavior.";
  this.ROYGBIV_SCRIPTING_API_STOPPURSUING = "Makes a steerable stop pursuing other steerables. It makes sense to use this API with PursueBehavior,\nafter using pursue API.";
  this.ROYGBIV_SCRIPTING_API_STOPEVADING = "Makes a steerable stop evading other steerables. It makes sense to use this API with EvadeBehavior,\nafter using evade API.";
  this.ROYGBIV_SCRIPTING_API_GETJUMPDESCRIPTOR = "Returns a JumpDescriptor object or 0 if JumpDescriptor does not exist.";
  this.ROYGBIV_SCRIPTING_API_JUMP = "Makes a steerable manually jump. toTakeoffBehaviorName parameter represents the steering behavior used until the steerable reaches\nto the takeoff point. completeCallback function is executed when the jump is completed. When a jump is completed, a steering behavior\nneeds to be set to the steerable in order to continue the movement. Note that this API returns false if the jump\ndescribed by the jumpDescriptor is not achievable by given steerable, true otherwise.";
  this.ROYGBIV_SCRIPTING_API_SETPATHFINISHLISTENER = "Sets a path finish listener for PathFollowingBehavior of given steerable object. The callbackFunction is executed\nwhen the path of given PathFollowingBehavior is consumed.";
  this.ROYGBIV_SCRIPTING_API_REMOVEPATHFINISHLISTENER = "Removes a path finish listener for PathFollowingBehavior of given steerable object.";
  this.ROYGBIV_SCRIPTING_API_SETOBJECTMOUSEMOVELISTENER = "Sets a mouse move listener for given object. The callbackFunction is executed with x, y, z parameters every frame\nthe mouse is on given object.";
  this.ROYGBIV_SCRIPTING_API_REMOVEOBJECTMOUSEMOVELISTENER = "Removes the mouse move listener from given object.";
  this.ROYGBIV_SCRIPTING_API_STARTALLANIMATIONS = "Starts all animations of given object, object group, text or sprite.";
  this.ROYGBIV_SCRIPTING_API_SETPOSITIONCHANGELISTENER = "Sets a position change listener to given object or object group. The callbackFunction is executed with\nx, y, z coordinates everytime the position of the object changes.";
  this.ROYGBIV_SCRIPTING_API_REMOVEPOSITIONCHANGELISTENER = "Removes a position change listener from given object.";
  this.ROYGBIV_SCRIPTING_API_EXECUTEFOREACHWAYPOINT = "Executes func parameter with x, y, z coordinates for each waypoint of the path of given AStar object.\nNote that paths of AStar objects are reconstructed after finding the shortest distance, either manually\nor automatically by RandomPathBehavior.";
  this.ROYGBIV_SCRIPTING_API_ONSCENEEXIT = "Sets an exit callback function for given scene. The callback function is executed before the scene changes.";
  this.ROYGBIV_SCRIPTING_API_REMOVESCENEEXITLISTENER = "Removes a scene exit listener for given scene.";
  this.ROYGBIV_SCRIPTING_API_SETSTEERABLELOOKDIRECTION = "Sets the look direction of given steerable. Unlike setSteerableLookTarget API which eventually makes a steerable\ngradually look at given target depending on the lookSpeed of the steerable, this API immediately modifies the look\ndirection.";
  this.ROYGBIV_SCRIPTING_API_GETSTEERABLELOOKDIRECTION = "Fills the targetVectot with the look direction of given steerable object and returns it.";
  this.ROYGBIV_SCRIPTING_API_SETOBJECTROTATIONMODE = "Sets the rotation mode of given object. rotationMode parameter may be either ROYGBIV.rotationModes.LOCAL or ROYGBIV.rotationModes.WORLD.\nLocal rotation mode indicates objects rotating around their own local axis unlike the world axis.";
  this.ROYGBIV_SCRIPTING_API_RESETOBJECTROTATION = "Resets all the rotations applied to given object.";
  this.ROYGBIV_SCRIPTING_API_RESETRANDOMPATHBEHAVIOR = "Ensures the RandomPathBehavior tries to start from the closest graph vertex to given steerable. This API may be useful\nwhen the random path behavior of object is changed to some other behavior before the object reaches to the destination vertex,\nand then the random path behavior is activated again. If given behavior is a blended or a priority steering behavior,\nthe child random path behaviors are reset.";
}
